
<h4>Web App Front-End Development Best Practices 2017 - A Lab Book</h4>
<p>new-page</p><p><em>If we complicate things, they get less simple.</em>
- Professor at Cambridge University</p>
<p><em>... Simplifications have had a much greater long-range scientific impact than individual feats of ingenuity. The opportunity for simplification is very encouraging, because in all examples that come to mind the simple and elegant systems tend to be easier and faster to design and get right, more efficient in execution, and much more reliable than the more contrived contraptions that have to be debugged into some degree of acceptability ... Simplicity and elegance are unpopular because they require hard work and discipline to achieve and education to be appreciated.</em>
- Edsger W. Dijkstra</p>
<p><em>Complexity is a sign of technical immaturity. Simplicity of use is the real sign of a well designed product whether it is an ATM or a Patriot missile.</em>
- Daniel T. Ling</p>
<p><em>Simplicity is the soul of efficiency.</em>
- Austin Freeman, &#39;The Eye of Osiris&#39;</p>
<p><em>La perfection est atteinte non quand il ne reste rien à ajouter, mais quand il ne reste rien à enlever.</em>
[Perfection is not achieved when nothing needs to be added, but when there is nothing left to remove.]
- Antoine de Saint-Exupéry</p>
<p><em>Controlling complexity is the essence of computer programming.</em>
- Brian Kernighan</p>
<p><em>Der Unterschied zwischen einem guten und einem schlechten Architekten besteht heute darin, daß dieser jeder Versuchung erliegt, während der rechte ihr standhält.</em>
[The difference between a good and a bad architect today is that one yields to every temptation, while the right one resists it.]
- Ludwig Wittgenstein</p>
<p><em>Simplicity does not precede complexity, but follows it.</em>
- Alan J. Perlis </p>
<ul>
<li></li>
</ul>

<p>new-page</p>
<h3>Wolfgang Gehner</h3>
<p></p>
<h1>Web App Front-End Development Best Practices 2017 </h1>
<h3>A Lab Book </h3>
<p>Kindly supported by: appthings.io</p>
<p>new-page</p>
<p>1st Edition 2017</p>
<p></p>
<p>Copyright &copy; Wolfgang Gehner (wgehner@gmail.com)</p>
<p>Contact hi@appthings.io for rights to reproduce this book in any form.  </p>
<p>In almost all cases, code is licensed under the MIT license. Check https://rawgit.com/topseed/topseed/master/LICENSE.md for exceptions.</p>
<p>new-page</p>
<h3>Table of Contents</h3>
<p></p>
<h3>Part I: The Basics</h3>
<h3>Part II: The Bricks and Mortar</h3>
<h3>Part III: The Perspectives</h3><h2 id="agenda-">Agenda:</h2>
<p>The Basics</p>
<ul>
<li><p><a href="./1-helloWorld/">1: Hello World and Markdown</a></p>
</li>
<li><p><a href="./2-theBasics/">2: Material Design, SASS and Pug</a></p>
</li>
<li><p><a href="./3-goLive/">3: Go-Live - Deploy to Cloud and use a CDN</a></p>
</li>
<li><p><a href="./4-appShell/">4: AppShell, Turbo and Caching for Performance</a></p>
</li>
</ul>
<p>The Bricks and Mortar</p>
<ul>
<li><p><a href="./5-amp/">5: Accelerated Mobile Pages (AMP) and Node.js</a></p>
</li>
<li><p><a href="./6-read/">6: UI Reading from an API</a> </p>
</li>
<li><p><a href="./7-write/">7: UI Writing to an API (Example: Firebase)</a> </p>
</li>
<li><p><a href="./8-security/">8: Login Security and Tokens</a></p>
</li>
</ul>
<p>The Perspectives</p>
<ul>
<li><p><a href="./9-comps/">9: Standard Web Components and their Communication</a></p>
</li>
<li><p><a href="./10-mobile/">10: Mobile App (Phonegap)</a></p>
</li>
<li><p>11: Next Edition: Extreme SEO with server-side rendering (SSR) of Web Components and server-side BLX</p>
</li>
</ul>

<p>new-page</p>
<h2>Part I: The Basics</h2>
<p>new-page</p><h2 id="lab-1-hello-world-using-markdown-with-preprocessor">Lab 1: Hello World - Using Markdown with Preprocessor</h2>
<ol>
<li><p>Downloand and unzip topseed-helloworld-master.zip from <a href='https://github.com/topseed/topseed-helloworld' target='_blank'>https://github.com/topseed/topseed-helloworld</a> to your location of choice on your developer machine.</p>
</li>
<li><p>Open your Google Chrome web browser and install the &#39;Web Server for Chrome&#39; app from <a href='https://chrome.google.com/webstore/search/Web%20Server?_category=apps' target-'_blank'>https://chrome.google.com/webstore/search/Web%20Server?_category=apps</a>. Launch the app, click the &#39;Choose Folder&#39; button and select the /helloworld-webroot folder under /topseed-helloworld/topseed-srv. Also ensure Options has &#39;Automatically show index.html&#39; checked. Ensure the Web Server is STARTED, then navigate to the proposed URL (eg. <a href='http://127.0.0.1:8887' target='_blank'>http://127.0.0.1:8887</a>. You should see a demo website. Explore the site. It uses &#39;responsive design&#39;. Resize the browser from fullscreen to narrow to see the layout adapt. </p>
</li>
<li><p>Download, install and run &#39;Visual Studio Code&#39; (VS Code) from <a href='https://code.visualstudio.com/download' target='_blank'>https://code.visualstudio.com/download</a>. From &#39;File&#39; menu, choose &#39;Open Folder...&#39; and select folder /topseed-helloworld. When the project is loaded, inspect the default entry page at /topsseed-srv/helloworld-webroot/index.html We like VS Code, but you can use any other editor of your choice.</p>
</li>
<li><p>Download, install and run Prepros (Unlimited Trial) from <a href='https://prepros.io/downloads' target='_blank'>https://prepros.io/downloads</a>. Use the + button on the bottom left to add the folder /helloworld-webroot (under /topseed-srv) as a new project. In Project/Settings/Compiler Settings/Markdown, uncheck &#39;Wrap with Html&#39;. </p>
</li>
<li><p>In the browser, return to the home page (e.g. <a href='http://127.0.0.1:8887' target='_blank'>http://127.0.0.1:8887</a>). In VS Code, open /helloworld-webroot/page/one/_hello.md and prefix the text with &#39;Hello World!&#39; Save the file. In the same folder, inspect _hello.html. Prepros will have &#39;preprocessed&#39; your edited &#39;Markdown&#39; file to HTML. Refresh the browser and see the edits. Search Google for &#39;Markdown syntax&#39;.</p>
</li>
<li><p>Optional: Use Prepros to auto-refresh on edits. In Prepros, click on the arrows on the right side of the prepros project name &#39;helloworld-webroot&#39;, check Sync Browsers and click Preview. (Or rightclick on &#39;helloworld-webroot&#39; and select &#39;Open Live Preview.&#39;) A browser should open and display the Home page. In VS Code, edit and save index.md again. The opened browser should refresh and include your changes.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-2-the-basics-material-design-sass-and-pug">Lab 2: The Basics - Material Design, SASS and Pug</h2>
<ol>
<li><p>Ensure you have the sample project topseed-helloworld open in VS Code and Prepros running on the /topseed-webroot folder. Per Lab 1, make sure the home page is running in a browser.</p>
</li>
<li><p>Visit and browse these sites: <a href='http://materialpalette.com' target='_blank'>http://materialpalette.com</a>, <a href='https://design.google' target='_blank'>https://design.google</a>, <a href='https://material.io' target='_blank'>https://material.io</a> and
<a href='https://material.io/guidelines/#' target='_blank'>https://material.io/guidelines/#</a>. We follow Material design guidelines, put forward by Google, to make our sites and mobile apps look better. </p>
</li>
<li><p>Find /_sass/main.css in the home page source, and inspect it. Other than fonts, all CSS used on the site is in this one CSS.</p>
</li>
<li><p>Visit <a href='https://www.muicss.com' target='_blank'>https://www.muicss.com</a>. Read &#39;Getting Started/Introduction&#39;, then browse the section &#39;CSS/JS&#39;. We use the MUI CSS libraries in our project. Inspect /_sass/_base.scss in /helloworld-webroot. SCSS is CSS with some added features, such as $variables and @import. You can turn any CSS file into SCSS by just changing the ending to .scss.</p>
</li>
<li><p>Inspect /_sass/_colors.scss in /helloworld-webroot.See a color scheme we generated with materialpalette.com. Use /* */ to comment it out. Go back to <a href='http://materialpalette.com' target='_blank'>http://materialpalette.com</a>, pick two colors, download your own palette in CSS format and paste it after the section you commented out. Save and refresh the browser, and you should see your new color scheme applied to the site. Revert to the palette you had commented out.</p>
</li>
<li><p>Inspect /_sass/main.sass. SASS uses a special syntax without the curly braces or &#39;;&#39; at the end of a line that are used in CSS (and SCSS). SASS can also use SCSS imports such as @import &#39;_base&#39;. Prepros compiles the .sass and its dependent .scss imports into the single &#39;main.css&#39; used in the browser. In Prepros Files select _main.sass, check &#39;Minify Css&#39;, and click Process File. Open /_sass/main.css and see that it is now minified.</p>
</li>
<li><p>Inspect /page/two/_buttons.html Copy the entire HTML. Go to <a href='http://html2jade.org' target='_blank'>http://html2jade.org</a> (Pug used to be called Jade) and paste this html. In the right pane you see Pug markup, a way to write html without having to
worry about closing tags. We write Pug. </p>
</li>
<li><p>Inspect the code snippet at /page/two/_buttons.pug. It should match the output of html2jade. Every .pug file in the project has a corresponding .html used by the browser, with the exception of include&#39;s within another pug file. Inspect /page/two/index.pug to find the &#39;include _buttons&#39;. Inspect /page/two/index.html to find the generated buttons html.</p>
</li>
<li><p>Watch the video &#39;Do you Even JADE bro&#39; at <a href-"https://www.youtube.com/watch?v=wzAWI9h3q18" target="_blank">https://www.youtube.com/watch?v=wzAWI9h3q18</a>. Once you know how to write Pug, you can generate beautiful html quickly.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-3-go-live-deploy-to-cloud-and-use-a-cdn">Lab 3: Go-Live - Deploy to Cloud and use a CDN</h2>
<ol>
<li><p>Go to <a href='https://zeit.co'target='_blank'>https://zeit.co</a> and create a free account. We use their NOW product to deploy our apps for testing in the cloud. Install the NOW client.
Instead, you could zip up the /helloworld-webroot folder and deploy to any
static web hosting service via FTP. However, we will need some &quot;dynamic&quot;, server-side features later, so we wrap our static webroot content with some code that works on a Node.js server, such as used by NOW.
Rename /helloworld-webroot/cache.mfx to cache.mf.</p>
</li>
<li><p>To deploy, drag the /topseed-srv folder into the ZEIT.co NOW client. For advanced users: this folder includes index.js and package.json needed by Node.js.
Once the deployment is completed, your clipboard will have a URL unique to the version you deployed. Test the URL in the browser. Bookmark the URL. You are in the Cloud and live on the Web!</p>
</li>
<li><p>The remainder of this lab is optional for development (but mandatory for QA/Staging/Production): To give your site a &quot;proper&quot; domain, you will need a domain name and DNS. If you do not have a domain yet, we recommend to register a cheap domain at <a href='https://www.namecheap.com/' target='_blank'>https://www.namecheap.com</a> now and have it use the namecheap DNS.
If you already own a domain and host a site, e.g. at www.mydomain.com, you may want to configure a CNAME to map a &#39;staging&#39; subdomain, such as staging.mydomain.com, so you can keep using www for your public site. See below for more detailed instructions. </p>
</li>
<li><p>For scalability and caching, you will also want to use a Content Delivery Network (CDN). With a CDN, you also get SSL/HTTPS for free. No need to buy an expensive SSL certificate. SSL is important when using advanced Javascript functions in the browser, such as cross-domain data requests. We recommend <a href='https://www.cdn77.com' target='_blank'>https://www.cdn77.com</a>. For this tutorial, register for the CDN77 14-day free trial now.</p>
</li>
<li><p>In the CDN77 web app, go to menu item CDN and click &quot;ADD NEW CDN RESOURCE&quot;. Give it a label, such as &#39;staging.mydomain.com&#39; and select &quot;My Origin&quot;. As domain, specify HTTPS and the ZEIT.co DOMAIN from the URL you bookmarked under 2. (e.g. demos-oosnsyzlphl.now.sh). Click &quot;CREATE CDN RESOURCE&quot;.</p>
</li>
<li><p>Choose 4-step setup with CNAME. Click &quot;Add new CNAME&quot;, and &quot;+ ADD CNAMES&quot;. Enter &quot;staging.mydomain.com&quot; and Click &quot;ADD CNAME&quot;. Click &quot;Go back to Integration&quot;. In Step 2, copy the DOMAIN NAME (AKA HOST), e.g 1234567890.rsc.cdn77.org, then follow instructions for your hosting provider. If your domain is with namecheap.com, do the following:
On the namecheap dashbord, click &quot;Manage&quot; for your domain, and &quot;Advanced DNS&quot;. Click &quot;ADD NEW RECORD&quot;, select &quot;CNAME&quot; and enter the following: Host: staging Value: [DOMAIN NAME from clipboard, e.g. 1234567890.rsc.cdn77.org], TTL: Automatic. Click checkmark to save.
No need to do CDN77 Step 3. One final step is to go to the &quot;Other Settings&quot; tab, check &quot;HTTPS redirect&quot; and click &quot;SAVE CHANGES&quot;.</p>
</li>
<li><p>After an hour after the initial setup, you should be able to reach the deployed site in your browser under e.g. <a href='https://staging.mydomain.com' target='_blank'>https://staging.mydomain.com</a>. Note the use of &quot;https&quot;. If you visit too quickly, the browser will complain that the site certificate is invalid. If this happens, try again after a while. The CDN caches static files for greater performance in multiple distributed datacenters. For advanced users: Cache-Control response headers are set in /topseed-srv/util/Decider.js.</p>
</li>
<li><p>Edit /helloworld-webroot/page/one/_hello.md again (see Lab 1: 5.). To deploy the change, follow step 2 above. In CDN77 Overview, change &quot;What is your domain?&quot; to the new URL, and click &quot;SAVE CHANGES&quot;. To make the changes appear on the CDN edge servers immediately, use CDN77 &quot;CDN/Purge&quot; on /page/one/.</p>
</li>
<li><p>Optional: Once you are ready to move from staging to production, you would either edit the CNAME for www to point to the same CDN domain (e.g. 1234567890.rsc.cdn77.org) or add a new CDN resource such as &#39;www.mydomain.com&#39; that may also use a new ZEIT.co domain created when redeploying the app to ZEIT.co NOW (see 2.)</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-4-appshell-turbo-and-caching-for-performance">Lab 4: AppShell, Turbo and Caching for Performance</h2>
<ol>
<li><p>Inspect /helloworld-webroot/page/one/index.pug and /page/two/index.pug. These Pug files show how the parts of the &#39;HTML they have in common are pulled from central places. Both pages use or &#39;extend&#39; the TEMPLATE /_part/_baseShell.pug. Open this template file, and see that it has &#39;blocks&#39; named &#39;head&#39;, &#39;main&#39;, and &#39;footer&#39;. The Pug pages that extend this template define how to replace these blocks. For example, /page/one/index.pug defines that the head block consists of a page-specific title tag and an included fragment /_part/_header.pug. The same _header.pug is re-used by /page/two/index.pug.</p>
</li>
<li><p>Inspect /helloworld-webroot/_part/_top.pug. This fragment represents the top menu and side drawer used on all pages. You can find it referenced in /_part/_baseShell.pug as &#39;include _top&#39;. Now inspect /page/one/index.html. This is the complete HTML which Prepros has collated together from template and fragments. Since the server has been configured to return the &#39;default&#39; page index.html when the browser requests /page/one/, this is what the end user sees. </p>
</li>
<li><p>You have seen that a pug template or fragment can include other pug fragments. It can also include a fragment which is already in HTML format, such as /page/one/hello.html included in /page/one/index.html. hello.html is the result of processing the &#39;markdown&#39; file hello.md. We find that Pug is not only a great way to write clean HTML, it is also very useful for defining layouts and reusing page elements.</p>
</li>
<li><p>To give the application a &#39;Single-Page Application&#39; feel, we use an optional JavaScript library called topseed-turbo (&#39;TT&#39;). When a user navigates from one URL to the next, TT replaces only the part of the HTML body that is unique to each page (The section marked &#39;#content-wrapper&#39; in _baseShell.pug and /_js/main.js). TT is unobtrusively loaded by JavaScript included in the _header.pug section (/setup-x.x.js). Using TT avoids &#39;page flash&#39; and makes for smoother navigation, very similar to a native &#39;rich client&#39; app where only individual panels are replaced on navigation. Smoother navigation increases the perceived performance of the application.</p>
</li>
<li><p>(Optional) Advanced JavaScript users may be interested to look at TS.onAppReady(UIinit) in /page/one/index.pug. TS stands for topseed-setup. TS receives an event when the #content-wrapper HTML is fully present in the browser (similar to a &#39;pageLoaded&#39; event). When using TT, TS.onAppReady provides an important &#39;hook&#39; for page-specific JavasSript that requires the DOM to be fully initialized.</p>
</li>
<li><p>Rename /helloworld-webroot/cache.mfx to /cache.mf and inspect it. The AppCache is a good way to improve performance of a web application. The file is referred to as &#39;manifest&#39; in /_part/_baseshell.pug.  If the manifest file is present, the browser will keep its listed resources in the browser cache &#39;forever&#39;, and serve them from there, without going to the network, until the cache.mf file itself changes. You can see what the browser does with this AppCache if you run a page in Developer mode (hit Ctrl-Shift+i and select the &#39;Console&#39; tab in your Chrome browser). For development, we disable the AppCache by renaming it from .mf to .mfx. If you ever suspect the browser having cached an older version of a resource, rightclick the refresh button on the left of the URL in the Chrome browser and select &quot;Empty Cache and Hard Reload&quot;.</p>
</li>
<li><p>In a later tutorial, we will discuss how we achieve additional performance gains by setting response headers to allow caching of content at the &#39;edge&#39;.</p>
</li>
</ol>

<p>new-page</p>
<h2>Part II: The Bricks and Mortar</h2>
<p>new-page</p><h2 id="lab-5-accelerated-mobile-pages-amp-and-node-js">Lab 5: Accelerated Mobile Pages (AMP) and Node.js</h2>
<ol>
<li><p>AMP is a way to ensure that web pages render fast on mobile devices, for a better user experience (UX). Visit and browse <a href='https://www.ampproject.org/learn/overview/' target='_blank'>https://www.ampproject.org/learn/overview/</a> to learn more about AMP. Other than fast rendering, one advantage of AMP pages is that Google will cache AMP pages for you for free. There are some restrictions as to what a valid AMP page can include (such as no JavaScript), but it allows you to use the full power of CSS. Download and unzip topseed-master.zip from <a href='https://github.com/topseed/topseed' target='_blank'>https://github.com/topseed/topseed</a> to your location of choice on your developer machine. We use the &#39;dynamic&#39;, server-side features of Node.js to help with serving AMP pages where appropriate. It is, however, possible to create a completely static site that serves AMP. In this tutorial, we show how both AMP and non-AMP versions can share common resources to limit content duplication.</p>
</li>
<li><p>Install Node.js and NPM. If you have a MAC, follow the instructions at <a href-'http://blog.teamtreehouse.com/install-node-js-npm-mac' target='_blank'>http://blog.teamtreehouse.com/install-node-js-npm-mac</a>. If you have Windows, download and run the Installer from <a href='https://nodejs.org/en/download/' target='_blank'>https://nodejs.org/en/download/</a>, accept the default settings, and RESTART your computer. Open the project you downloaded in step 1 above with VS Code. Select menu View-Integrated Terminal. On the command line that opens, change directories with &#39;cd topseed-srv&#39;. To test Node, type &#39;node -v&#39; and hit Enter. You should see a version number like v8.0.0. To test NPM, type &#39;npm -v&#39; and hit Enter. You should see a version number like 4.0.3. Use Google to troubleshoot the install for your OS if necessary. </p>
</li>
<li><p>You are almost ready to run the topseed app in Node. First you will use NPM to download the &#39;dependencies&#39; listed in /topseed-srv/package.json. Go back to the Terminal Shell, make sure you are in the /topseed-srv directory, then type &#39;npm install&#39; and hit Enter. This will install the dependencies in a /node_modules directory. This will take a while, but the console will tell you when done. (Repeat this when you add a dependency yourself).</p>
</li>
<li><p>Inspect /topseed-srv/index.js. This is the JavaScript file that starts the app, including an &#39;express&#39; http server. Return to the Terminal Shell (still in the /topseed-srv directory) and type &#39;node index&#39; (you can omit the .js) and hit Enter to start the app. You should see output like &#39;App listening on port 8091 and 8092. (To stop it, you would press Ctrl+C).</p>
</li>
<li><p>In a browser, go to <a href='http://localhost:8091' target='_blank'>http://localhost:8091</a> and see /page/one/ come up. Rightclick on the page to &#39;Show HTML source&#39;. You will note that the head tag has AMP-specific content. To compare, review the HTML source or the non-AMP version at localhost:8092.
In production, we would likely map port 8091 to m.mydomain.com and port 8092 to www.mydomain.com. Behind the scenes, we have a Node module at /topseed-srv/util/Decider.js. The function of Decider is twofold: a) If a request of /page/one/ is on the first port, it will return the HTML from /page/one/indexA.html; if the request is on the second port, it will return the HTML from /page/one/index.html.  b) It will attempt to return the alternate version if the requested one does not exist, no matter what port the request came on.
You can change port numbers in /topseed-srv/config/ServerConfig.js (restart with &#39;node index&#39;).</p>
</li>
<li><p>Let us inspect how AMP pages are composed differently, but share some resources. Inspect &#39;/page/one/indexA.pug&#39;. Our convention is to post-fix AMP-specific resources with a capital A. See how /indexA.pug uses _baseShellA.pug and _headerA.pug, but uses the same _footer.pug as non-AMP /index.pug.
Likewise, both /index.pug and /indexA.pug share the use of _hello.html.
indexA.pug also has a required &#39;canonical&#39; link that points to the non-AMP version of the resource. Also note that /indexA.pug does not have the &#39;script&#39; element, since AMP does not permit custom JavaScript. AMP has some custom tags/components to help building AMP pages; see <a href='https://www.ampproject.org/docs/reference/components' target='_blank'>https://www.ampproject.org/docs/reference/components</a>.For example, JavaScript IS allowed inside an amp-iframe (example at <a href='https://m.appthings.io' target='_blank'>https://m.appthings.io</a>). </p>
</li>
<li><p>Inspect /_part/_baseShellA.pug. It includes _topA.pug, which is a non-JavaScript version of _top.pug that uses the #sidedrawer anchor combined with CSS to obtain the slide-out functionality without JavaScript. Also inspect /_part/_headerA.pug. It <em>includes</em> ../_sass/mainA.css inside a style(amp-custom=&#39;&#39;) tag. This means that the CSS for AMP is served inline rather than from a separate request. mainA.sass has the same content as main.sass, but having a separate file for mainA allows us to compress or &#39;mininize&#39; it (we use Prepros on the individual file) for inline use, since AMP files have a total size limitation.</p>
</li>
<li><p>Both AMP and non-AMP versions have the same responsive design features (they adapt to screen size). The AMP version should just be served faster, as optimized and privileged by Google caching. This may be especially important for the home page, where you do not want to let the user wait unnecessarily for the page to render. For custom behavior, you can force the non-AMP version by using the whole path /page/one/index.html in links or in the browser. We could make all &#39;a href&#39; links in the app to go to non-AMP versions by adding /index.html to them. We usually do this to take advantage of the (JavaScript-based) Topseed Turbo feature that provides for a smoother Single-Page Application feel.</p>
</li>
<li><p>In summary, the app supports fast AMP responses but provides for non-AMP fallback versions where necessary. For example, a &#39;Contact Us&#39; page that uses JavaScript to validate submissions would not have an AMP version. Decider.js on the server-side helps to automatically serve the available version.</p>
</li>
<li><p>You can use an AMP validator to ensure your AMP is valid; see <a href='https://validator.ampproject.org' target='_blank'>https://validator.ampproject.org</a> Your markup has to be valid to be indexed and cached by Google. If your page is online, you can revalidate and submit it at <a href='https://search.google.com/search-console/amp' target='_blank'>https://search.google.com/search-console/amp</a>.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-6-ui-reading-from-an-api">Lab 6: UI Reading from an API</h2>
<ol>
<li><p>For this and the next lab, we work on an &#39;Admin&#39; module that allows listing (and adding to) a &#39;Link Blog&#39;, or list of links. In a browser, go to <a href='http://localhost:8091' target='_blank'>http://localhost:8091</a> and click on the &#39;Admin&#39; menu item to navigate to the &#39;Topseed Admin Console&#39; (We will add login security in another lab). The Admin module has its own appshell and menu (see /_part/admin/). To signal a full screen refresh to turbo, we added a &#39;#&#39; to the link that leads to the Admin home screen at <a href='http://localhost:8091/admin/home/#' target='_blank'>http://localhost:8091/admin/home/#</a>. The refresh ensures that the standard menu (which would otherwise remain &#39;cached&#39; and re-displayed) is replaced by the Admin menu. </p>
</li>
<li><p>Click on the &#39;Linkblog&#39; menu item at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>to navigate to a list of Linkblog items. Rather than composing a screen in full on a server, modern web apps often take a HTML page to the browser first and then let the browser call an API to &#39;fill in&#39; the data, using JavaScript. This way, the static elements of a page can be served by a fast CDN, and the dynamic/data parts can be obtained directly from the data source.</p>
</li>
<li><p>The Linkblog list is populated with data coming from a JSON response to an API call. By default, the Lab project is configured to obtain the API response from a file at /topseed-webroot/linkblog/dummy.json or <a href='http://localhost:8091/linkblog/dummy.json' target='_blank'>http://localhost:8091/linkblog/dummy.json</a>. However, in the next lab we will call a real, live database API that resides on a separate API server. </p>
</li>
<li><p>Now click the &#39;Add Item&#39; button and note how the browser URL changed to <a href='http://localhost:8091/admin/linkblog/detail.html' target='_blank'>http://localhost:8091/admin/linkblog/detail.html</a>. This is a &#39;stable URL&#39; for the the data entry form to add/write a new item. &#39;Stable URL&#39; means that the page is not lost when you hit the browser refresh button, and that the page is &#39;bookmarkable&#39;, which is almost always a good thing. For now, click &#39;Cancel&#39; to return to the list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>.</p>
</li>
<li><p>Inspect /topseed-webroot/admin/linkblog/index.pug. This file defines the composition of the Linkblog list screen. In the &#39;HTML&#39; part of this file, the list is represented by the pug statement &#39;table#grid&#39; (&lt;table id=&quot;grid&quot;&gt;). The &#39;script.&#39; part of the file is responsible for causing the grid data to be loaded and rendered. The dot at the end of &#39;script.&#39; tells Pug to not convert what follows to HTML. </p>
</li>
<li><p>In &#39;script.&#39; we load external JavaScript that encapsulates logic, which keeps the page HTML clean and designer-friendly. In this example TS.loadOnAppReady loads /admin/linkblog/LinkblogBusiness.js, then calls the UIinit function in the page. This function triggers the &#39;list&#39; function of LinkblogBusiness, which asynchronously loads data from the API, and - once the data has been received - renders the grid as well as the data in the grid. Depending on how much data is to be loaded, a more advanced version of LinkblogBusiness could have a separate function (e.g. init()) to first render the grid without data, and the list() function would only load and render the list items.</p>
</li>
<li><p>Open /topseed-webroot/admin/linkblog/LinkblogBusiness.js and scroll to the end of the file. See how LinkblogBusiness wraps a &#39;SimpleBusiness&#39; object instance named &#39;sb&#39; that is returned to the page after we added a LinkblogDao &#39;Data Access Object&#39; instance. The page-specific custom functionality of SimpleBusiness is added close to the top of the file, beginning with &#39;var SimpleBusiness = BLX.extend({&#39;. We keep common business functionality in a base &#39;class&#39; named BLX.js (&#39;BusinessLogiX&#39;), and common data service functionality in BDS.js (BaseDataService). (Both are loaded by /_js/admin.js, the admin module version of main.js.) </p>
</li>
<li><p>In LinkblogBusiness.js we use &#39;var SimpleBusiness = BLX.extend({&#39; instead of the more recent &#39;class SimpleBusiness extends BLX {&#39;, because Internet Explorer does not support &#39;class&#39;. However, Microsoft&#39;s &#39;Edge&#39; browser supports it. We will use &#39;class&#39; once IE has lost its remaining popularity; see /admin/linkblog/LinkblogBusiness2.js for an example. Note the resulting improvement in function signatures e.g. &#39;list()&#39; vs &#39;,list: function()&#39;. If you can exclude the use of IE (such as for an internal webapp or a mobile app) we recommend you use the &#39;class&#39; version. You can read more about the IE-compatible version at <a href='http://johnresig.com/blog/simple-javascript-inheritance' target='_blank'>http://johnresig.com/blog/simple-javascript-inheritance</a>. To use the &#39;class&#39; version, in this example you would use TS.loadOnAppReady(&#39;/admin/linkblog/LinkblogBusiness2.js&#39; in /admin/linkblog/index.pug and /detail.pug and change /_js/admin.js to load BLX2.js and BDS2.js instead of BLX.js and BDS.js.</p>
</li>
<li><p>In LinkblogBusiness.js, inspect the code section following &#39;, list: function(listId)&#39;. The JavaScript in /admin/linkblog/index.pug triggers this function with &#39;sb.list(&#39;#grid&#39;)&#39;. Brushing over the details of obtaining the data for now, this function receives a &#39;_listPromise&#39; of data from the configured API. When data is returned, the function _renderList enters &#39;_listPromise.then(function(values){&#39;, builds the grid with the received values (a JSON array of rows) and renders it in the page element with id &#39;grid&#39;. There are many ways to render lists. In this example we use <a href='https://dataTables.net/' target='_blank'>https://dataTables.net/</a> to deliver advanced grid sorting, searching and paging features. </p>
</li>
<li><p>JavaScript Promises are a modern way to manage process flow. They are especially useful for handling asynchronous calls such as http requests to an API that may require error handling, such as connection errors. They replace classic asynchronous callbacks that are prone to &#39;Callback Hell&#39;; see <a href='http://callbackhell.com/' target='_blank'>http://callbackhell.com/</a>.  A lot of public APIs, such as Google Firebase, use or allow the use of Promises, and you can &#39;promisify&#39; those that don&#39;t. Promises are important, learn how they work at <a href='http://www.telerik.com/blogs/what-is-the-point-of-promises' target='_blank'>http://www.telerik.com/blogs/what-is-the-point-of-promises</a>. The post <a href='https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks' target='_blank'>https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks</a> may also help.</p>
</li>
<li><p>The LinkblogDao Data Access Object is responsible for obtaining the raw list data. See &#39;urlSpec&#39; at the top of LinkblogBusiness.js and how LinkblogDao extends BDS (which contains common data access functionality). Also see at the bottom of LinkblogBusiness.js how urlSpec is passed to LinkblogDao with &#39;sb.linkblogDao = new LinkblogDao(urlSpec)&#39;. In this case, unlike SimpleBusiness, LinkblogDao has no added functionality, so we could write &#39;sb.linkblogDao = new BDS(urlSpec) instead.</p>
</li>
<li><p>Inspect &#39;_/js/BDS.js and its &#39;selectList&#39; function. It calls a shared static _get function which uses fetch_ to call the urlSpec URL and returns a promise of the response content. &#39;Fetch&#39; is a modern replacement for Ajax/XMLHttpRequest. Fetch uses Promises! Read more about Fetch at <a href='https://davidwalsh.name/fetch' target='_blank'>https://davidwalsh.name/fetch</a>. At the end of the next Lab we learn how an API server can handle this fetch request. In this Lab, the content of /topseed-webroot/linkblog/dummy.json or <a href='http://localhost:8091/linkblog/dummy.json' target='_blank'>http://localhost:8091/linkblog/dummy.json</a> is returned.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-7-ui-writing-to-an-api-example-firebase-">Lab 7: UI Writing to an API (Example: Firebase)</h2>
<ol>
<li><p>In a browser, return to the Linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>, and click the &#39;Add Item&#39; button to see <a href='http://localhost:8091/admin/linkblog/detail.html' target='_blank'>http://localhost:8091/admin/linkblog/detail.html</a>. Note that the Date field is prepopulated with today&#39;s date. In VS Code, inspect /topseed-webroot/admin/linkblog/detail.pug. This file defines the composition of the Linkblog Add Item screen. In the &#39;HTML&#39; part of this file, the data entry form represented by the pug statement &#39;form#form1&#39; (&lt;form id=&quot;form1&quot;&gt;). Note that it has &#39;onsubmit=&#39;return false&#39;, because we do not want the browser default behavior of posting to a form action URL.</p>
</li>
<li><p>Similar to the  list page, in &#39;script.&#39; we load /admin/linkblog/LinkblogBusiness.js, and then call the UIinit function in the page. UIinit triggers the &#39;detail()&#39; function of LinkblogBusiness, which loads today&#39;s date into the form. UIinit also specifies to call the LinkblogBusiness save() function when the form is submitted (when the &#39;Save&#39; button is clicked) instead of the default behavior, and pass any authentication cookie along. Since we are working with similar data as in the list page, and the two pages belong together, we have chosen to augment LinkblogBusiness.js with the detail() and save() functions rather than creating separate LinkblogListBusiness and LinkblogAddBusiness. For a different module we would create a separate XxxBusinness.</p>
</li>
<li><p>Reopen /topseed-webroot/admin/linkblog/LinkblogBusiness.js and locate the &#39;detail: function(&#39;. We use <a href='https://momentjs.com/' target='_blank'>https://momentjs.com/</a> for date handling and jquery.jsForm <a href='https://github.com/corinis/jsForm' target='_blank'>https://github.com/corinis/jsForm</a> to populate the form with the date. The necessary libraries are loaded in /_js/admin.js. You see the result of the call to detail() when rendering of the page has completed.</p>
</li>
<li><p>Fill some data in the form and click &#39;Save&#39;. You should see an alert that saving is not enabled: we are not yet configured to use a database that allows saving. In LinkblogBusiness.js, locate the &#39;save: function(&#39;. Once we enable &#39;update&#39; in the urlSpec, processing will continue. We obtain the &#39;formData&#39; with jquery.jsForm(&#39;get&#39;), and pass it to the linkblogDao.update function. Once this has returned successfully (&#39;promise.then(&#39;), we redirect to the list page. BLX/sb has base functionality using turbo for the new page load.</p>
</li>
<li><p>Reopen BDS and look for the &#39;update: function(&#39;. It calls a shared static _post function which uses fetch_ to call the urlSpec update URL. </p>
</li>
<li><p>It is time to connect LinkblogDao/BDS to a live database. Go to the top of LinkblogBusiness.js, comment out the first urlSpec and comment in the urlSpec that goes to localhost:8081, does not use dummy.json and also has an update route, unlike the first urlSpec. We included a small API server implementation in the topseed project at topseed/bsrv that we will run at localhost:8081. The API server in turn will call a Google Firebase service that you will configure in the next step. Why do we not call the Firebase API directly from the browser? We do not want the browser to hold the authentication credentials for the database connection (more about user authentication in the next Lab).</p>
</li>
<li><p>Log into your Gmail/Google account at https://mail.google.com (Create one if you don&#39;t have one). Navigate to <a href='https://console.firebase.google.com/' target='_blank'>https://console.firebase.google.com</a>, click &#39;Add Project&#39;, enter &#39;mydb1&#39; as Project name when prompted and click &#39;Create Project&#39;.
Click the &#39;gear&#39; icon on the left menu (enlarge browser window if necessary to see it) to access Project Settings and click the &#39;Service Accounts&#39; tab. Copy the &#39;databaseURL&#39; value from the Node.js Admin SDK configuration snippet and paste it into the  topseed/bsrv/config/ApiConfig.js DB_URL return value. The line in ApiConfig.js should look something like &#39;get DB_URL() { return &#39;https://mydb1-7b77e.firebaseio.com&#39; }&#39; On the Google Project Settings Service Accounts tab, click &#39;Generate New Private Key&#39; and &#39;Generate Key&#39;. From the download prompt, save the file into the /topseed/bsrv/scode/route/ds/ folder. Open BaseFB.js, and replace &#39;serviceKey.json&#39; with the filename. The line should look something like const &#39;serviceAccount = require(&quot;./mydb1-7b77e-firebase-adminsdk-8swi6-f46e592e60.json&quot;)&#39; Verify that the path starts with &#39;./&#39;.</p>
</li>
<li><p>You are ready to start the API server that uses this configuration. In VS Code, open another Terminal Shell (Ctrl+Shift+`), type &#39;cd bsrv [enter]&#39;, do the &#39;npm install [enter] &#39; and then &#39;node index [Enter].
You should see console output &#39;API server listening at http://localhost:8081&#39;. On the VS Code terminal tab, use the dropdown go to the tab for topseed-srv, and start topseed-srv if not already running. You should see console output &#39;Web server listening at http://localhost:8091&#39; (and 8092).</p>
</li>
<li><p>In a browser, go to or refresh the Linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>. The list should now say &#39;No data available in table&#39;, because LinkblogBusiness urlSpec points to the newly configured API server that has an &#39;empty&#39; database. Click &#39;Add Item&#39;, enter some values and click &#39;Save&#39;. Your item should appear in the list. Back in the Google Firebase Console at <a href='https://console.firebase.google.com/' target='_blank'>https://console.firebase.google.com/</a>, for the project &#39;mydb1&#39;, navigate to &#39;Database&#39; from the menu tree on the left. You should be able to drill down to see the newly created entry in a table named &#39;links11&#39;. If you like, return to the Linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a> in the browser and add a few more items with &#39;Add Item&#39;.</p>
</li>
<li><p>Optional: Learn how the API server at /bsrv works. Inspect /bsrv/index.js. The line beginninng with &#39;server.use(&#39;/linkblog&#39;&#39; specifies that any requests to localhost:8081/linkblog are handled
by /scode/route/LinkblogService.js. Inspect this file. The function beginning with &#39;router.post(&#39;/&#39;&#39; specifies in the line &#39;const _promise = linkblog.update(row)&#39; that a post request will call the update function in /ds/Linkblog.js. Inspect this file. Linkblog.js specifies the table name as &#39;links11&#39;, but also extends BaseFB. (Since Linkblog.js runs in the Node.js server and not in the browser, we can use &#39;extends&#39; instead of .extends([). BaseFB has the common functionality to create a Firebase connection, query and update the database. For this, it uses the firebase-admin package imported as a dependency in /bsrv/package.json. To add a row, the BaseFB.js function &#39;update(row)&#39; was used. Similarly, a &#39;get&#39; request to localhost:8081/linkblog uses BaseFB.js &#39;selectList()&#39; to obtain the list of linkblog items. </p>
</li>
<li><p>Perspective: For a complete Create-Read-Update-Delete (CRUD) implementation, we would add single-row query, update and delete capablity. To edit existing items, we would navigate to &#39;/detail.html?id=x&#39; and, in LinkblogBusiness detail(), use the &#39;id&#39; URL parameter to obtain the existing data querying by a primary key column or unique index on the database. If you were to use a database service provider other than Google Firebase, you would create an implementation of BaseFB.js using the alternative provider&#39;s API, following the provider&#39;s examples for Node.js. </p>
</li>
</ol>

<p>new-page</p><h2 id="lab-8-login-security-and-tokens">Lab 8: Login Security and Tokens</h2>
<ol>
<li><p>Until now we had login security for the Admin module disabled. Inspect /admin/login/index.pug, and look for &#39;//sb.redirect(&#39;/admin/home/&#39;). Uncomment it by removing &#39;//&#39;. Ensure the API service is running. Return to the home page at <a href='http://localhost:8091' target='_blank'>http://localhost:8091</a>, and click the &#39;Admin&#39; menu item to see the login prompt. Use &#39;demo&#39;:&#39;demo&#39; as username:password and click &#39;Login&#39;. In VS Code, return to /admin/login/index.pug. See how we open the modal dialog, bind the form and register the form submit. Modal dialogs are natively supported by the Chrome browser. We use a &#39;polyfill&#39; (loaded in /_js/admin.js) for compatibility with other browsers (Edge and IE need a little bit of CSS love). LoginBusiness &#39;login()&#39; contacts the API server (it could be a separate server dedicated to authentication). If the credentials match, LoginBusiness receives an &#39;OK&#39; response, and we redirect to /admin/home/. If an authentication error is received, we display it in a div with id &#39;error&#39; on the page.</p>
</li>
<li><p>Along with the &#39;OK&#39; response, the API server returned a &#39;token&#39; string. We store the token as a cookie (name: &#39;auth&#39;) in the browser. After the initial login, we use this token on all pages and for all API calls that require auhentication. While instead we could have stored username and password as a cookie, the advantage of using a token after initial authentication is that it can be heavily encoded (by the server). For maximum security and defense against network sniffing, the token could even be changed on every request.</p>
</li>
<li><p>To protecte the Linkblog pages with a login, open /admin/linkblog/index.pug and /detail.pug and uncomment //sb.ensureLogin(...). This function checks for the existence of the &#39;auth&#39; cookie. If this cookie doesn&#39;t exist, it means that the user has not logged in, and he is redirected to the login screen. We destroy the &#39;auth&#39; cookie on logout; see &#39;script.&#39; in /admin/logout/index.pug. Logout is triggered when clicking the admin menu &#39;Logout&#39; item.</p>
</li>
<li><p>There is one more thing to improve. In our flow, on full page refresh, the browser renders the static parts of the page before ensuring login. The ugly result is that the admin menu bar, static page content and footer may briefly display before a redirect to the login page happens. This is by design; we allow a CDN to cache the static (non-data) parts of admin module pages. However, we can apply a visual improvement to achieve better transitions. Open &#39;_sass/admin.sass&#39; and uncomment the last two lines, beginning with &#39;//body > *&#39;. This sets the opacity of the immediate children of the admin html body to a very low 0.1 by default (You can set it to 0, if you prefer). Linkblog.ensureLogin sets the opacity to 1 when the user has been confirmed to have successfully logged in, causing the page to display in full. Save admin.sass and try the login routine again to see the result. We could also imagine using a spinner during the transition; see <a href='http://spin.js.org/spinner' target='_blank'>http://spin.js.org/spinner</a>. </p>
</li>
<li><p>For additional security, we send the token along when we make requests to the API server. If the API server is configured to require authentication, we ensure that the specific token received allows reading or writing the data before returning the data. If the token is not valid, we let the API service return a 403 &#39;Forbidden&#39; error. When LinkblogBusiness receives such an error, we show an alert and redirect to the login page. Open /bsrv/config/ApiConfig.js to configure which API calls are to be secured. In the line for &#39;get REQUIRE_AUTH&#39;, uncomment &#39;write&#39; so that it reads &#39;linkblog: [&#39;write&#39;]&#39;. Restart the server in the terminal window. This activates the token check in /bsrv/scode/route/LinkblogService.js in &#39;router.post(&#39;. The class TokenAuth contains our very simple Authentication functionalities: validate that username:password match demo:demo, and token always matches &quot;abc&quot;. </p>
</li>
<li><p>You just activated token security for the Linkblog write (=save) function. Let&#39;s inspect how the token is passed to the API. In /admin/linkblog/detail.pug, with &#39;$(&#39;#form1&#39;).submit({auth: Cookies.get(&#39;auth&#39;)}, sb.save)&#39; we instruct to include the auth cookie as event data when calling LinkblogBusiness.save. In LinkblogBusiness &#39;save&#39;, we pass it on to the DAO in &#39;sb.linkblogDao.update(formData, e.data.auth)&#39;. This continues through BDS.js update, _post and fetch_ functions, where the token is  passed to the API as &#39;X-JToken&#39; header. If configured as described above, in /bsrv/scode/route/LinkblogService.js the API reads this header and validates the token by calling &#39;/bsrv/scode/route/ds/TokenAuth.js &#39;isTokenValidPromise&#39;. 
Inspect this function. The returned promise throws an &#39;invalid token&#39; error in the case of failure, which causes LinkblogService to abandon the update request and return a 403 error &#39;Forbidden&#39;.</p>
</li>
<li><p>Reopen /admin/linkblog/LinkblogBusiness.js and find &#39;const _updatePromise&#39;. Here follows what happens in the UI as a result of the update attempt. If the update/save was successful, we redirect to the linkblog list page. If it failed because the token did not validate (&#39;Forbidden&#39;), show an alert and redirect to the login page. In case of other failures, simply show an alert. If you wish to simulate the errors, go to /admin/linkblog/detail.pug and make it send an invalid token with &#39;$(&#39;#form1&#39;).submit({auth: &#39;xyz&#39;}, sb.save)&#39;. Attempt to add and save a new linkblog item. Revert to &#39; $(&#39;#form1&#39;).submit({auth: Cookies.get(&#39;auth&#39;)}, sb.save)&#39; when done. Since our linkblog is expected to be public, we didn&#39;t implement authentication for the linkblogDAO.selectList API call, but this could easily be added.</p>
</li>
<li><p>This Lab demonstrated the fundamentals of the two principal authentication flows: login and token validation. A &#39;real life&#39; authentication provider would likely be more advanced than TokenAuth.js. Tokens might need to be encoded and decoded. A production implementation might access a database of credentials, an in-memory database of valid tokens, or an asynchronously called external authentication service that may return its own promises for credential and token validations. In the shown implementation, sucessful login always redirects to the admin landing page. For production, we would probably enhance the login flow by keeping track of which protected page was requested and redirect to it after successful login. </p>
</li>
</ol>

<p>new-page</p>
<h2>Part III: The Perspectives</h2>
<p>new-page</p><h2 id="lab-9-standard-web-components-and-their-communication">Lab 9: Standard Web Components and their Communication</h2>
<ol>
<li><p>The quest for the web equivalent of &#39;Legos&#39; has been going on for a while. Legos are composable: you can connect pieces in different ways. They are reusable: the same kind of piece can be used in multiple places. Legos are also modular: you can connect one assembly to another one. Unlike Legos <a href='https://www.kickstarter.com/projects/1068475467/brixo-building-blocks-meet-electricity-and-iot' target='_blank'>(mostly; google kickstarter brixo )</a>, however, components for the web also need to be able to communicate with each other and with the outside world. Finally, web components need to be insulated (in Lego terms, the color of one item must not &#39;bleed&#39; into others). CSS &#39;bleed&#39; has been a particular problem of older web component frameworks. To find an overall solution for great web components is not trivial, and many attempts have been made to achieve the holy grail of component-based development for the web.</p>
</li>
<li><p>In reality, component frameworks have had a short half-life. The last years has seen a rapid succession of candidates to be considered &#39;the best&#39;: Backbone, Knockout, Ember, Angular, Angular 2, React, Vue, Riot and Polymer. Find a comparison of component frameworks at <a href='http://jeffcarp.github.io/frontend-hyperpolyglot/' target='_blank'>http://jeffcarp.github.io/frontend-hyperpolyglot/</a>. History shows that what you would pick today is likely not what you would pick 18 months from now. Assuming you don&#39;t want to start from scratch and rewrite everything every 18 months, that presents you with a great challenge of how to write applications that you can expect to be both maintainable and future-safe.</p>
</li>
<li><p>Our best practice to deal with the evolving landscape of web components is to write webapps that are structured in a &#39;component-framework-agnostic&#39; way, where you can potentially keep existing components around, but develop new components using a newer component framework. We achieve this by avoiding the use of the two kinds of common component framework features that create unattractive &#39;lock-in&#39;: custom navigation mechanisms (routers) and framework-specific component communication implementations. We use the browser&#39;s great native navigation mechanisms (URL and browser history) as shown in Lab 4, and framework-agnostic component communication as implemented in the sample project shown below. </p>
</li>
<li><p>There is, however, light at the end of the tunnel: a W3C standard for web components appears to be forming.  Read about Standard Web Components at <a href='https://en.wikipedia.org/wiki/Web_Components' target='_blank'>https://en.wikipedia.org/wiki/Web_Components</a>. The Chrome browser already supports Standard Web Components natively, so there is nothing extra to load, and the polyfills for the other browers are lean and fast. The most recent contender for &#39;the best&#39; component framework, Polymer, is actually developed on top of this emerging standard, by the same people at Google in charge of the standard reference implementation. We use standard web components as the default component framework for this Lab. However, our architectural concepts can also be applied when using other frameworks. May we tempt you to write a sample integration for your favorite component framework and contribute it to topseed?</p>
</li>
<li><p>Among other things, newer component frameworks solve the problem of CSS bleeding by using the &#39;Shadow DOM&#39; construct. To work with web components you should understand Shadow DOM; read a good introduction at <a href='https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/' target='_blank'>https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/</a>. We prefer it over the more recent introduction at 
<a href='https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom' target='_blank'>https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom</a>. &#39;Templates&#39; and &#39;HTML Imports&#39; are other Standard Web Component features which will become clear with the examples in this Lab. Finally, there is a &#39;Custom Element&#39; API to create new HTML tags. However, the implementation of this API uses &#39;class&#39; which is not supported by Internet Explorer. We will use the Custom Element API once IE has lost its remaining popularity, or when we can rule out IE in a corporate app. </p>
</li>
<li><p>Download and unzip topseed-webcomps-master.zip from <a href='https://github.com/topseed/topseed-webcomps' target='_blank'>https://github.com/topseed/topseed-webcomp</a> to your location of choice on your developer machine. Open the project in VS Code. Add the project folder /topseed-webcomps in Prepros, but but ensure that Auto-Compile of Pug (Jade) is deactivated (Settings/Compiler Settings/Pug (Jade). In this project, Node.js compiles pug files on the fly when responding to HTTP requests so we don&#39;t need Preprose to precompile them. See the function &#39;pugComp&#39; in /demo-srv/util/Decider.js. Since in production we cache generated HTML responses in the CDN, there is practically no impact on production performance, but the development project is a lot cleaner. While reviewing &#39;Decider.js&#39;, also take note of all uses of &#39;U.cache&#39;, which tells the CDN how long to keep content before refreshing it from the source. The utils library &#39;U&#39; is included in the project https://github.com/topseed/topseed-npm, deployed to npmjs, and imported to the project through a &#39;package.json&#39; dependency. </p>
</li>
<li><p>In VS Code, open Terminal Shell (Ctrl+Shift+`), type &#39;cd demo-srv [Enter]&#39;, do the &#39;npm install [Enter]&#39; and then &#39;node index [Enter]&#39;.
You should see console output &#39;Web server listening at http://localhost:9081&#39;. In the browser, navigate to <a href='http://localhost:9081' target='_blank'>http://localhost:9081</a>, and visit Dashboard, List, Circle, Prelist and List menu items. When writing a component, we always advise to make things work outside of a component first. &#39;Prelist&#39; is a non-component list page. In VS Code, inspect its /demo-srv/root/page/list-0/index.pug. Similar to the admin linkblog in tutorial 6, this page uses &#39;/page/list/ListBusiness.js&#39; to load a list from a JSON response promise. For data binding, ListBusiness.list() uses doT.js, a fast &#39;moustache-style&#39; template library. The doT template is embedded in the page html as a script of type &#39;text/x-dot-template&#39;. Inspect ListBusiness.js, beginning with &#39;var templateText&#39; to see the JavaScript used to render the template with data and attach it to &#39;#myList&#39; in the page. You can read more about doT at <a href='http://www.javascriptoo.com/dot-js' target='_blank'>http://www.javascriptoo.com/dot-js</a>.</p>
</li>
<li><p>Inspect the component version of the list page at /demo-srv/root2/page/list/index.pug. It has a custom element in the html named &#39;list-el&#39;. Custom elements must include a &#39;-&#39; (dash) in the tag name. The doT template has disappeard. The page &#39;script.&#39; loads ListBusiness.js and the List component definition from the &#39;HTML Import&#39; /_webComp/List.html, registers the &#39;component prototype&#39; with the browser using TW.registerComp and then calls sb.compList() to render an instance of the component. In /page/list/ListBusiness.js, compare the function &#39;compList&#39; with the function &#39;list&#39; used by the non-component version. In this example, the &#39;compList&#39; function obtains the component instance with &#39;document.querySelector&#39; and calls its list(values) function. We always pass data to a component, instead of making the component load data. This keeps the component simpler and more manageable. As a result of using a component, both the page and ListBusiness are somewhat cleaner; &#39;JavaScript mess&#39; is hidden inside the component.</p>
</li>
<li><p>Optional: Inspect the list component implementation at /demo-srv/root2/_webComp/List.pug. You will find the Standard Web Component &#39;template&#39; tag that includes the node #myList previously seen in the non-component page, as well as the x-dot-template. The &#39;script.&#39; section creates a HTMLElement prototype named &#39;ListEl&#39;, specifies to attach the insulated shadow DOM (using TW.attachShadow) when an actual component instance is created from the prototype (&#39;createdCallback&#39;). Also see the ListEl.list function implementation which places the databinding result into the &#39;#myList&#39; node in the shadow DOM. (You can find the the &#39;TW.&#39; helper library function implementations in /demo-srv/root2/_js/tw-2.0.js.) </p>
</li>
<li><p>As of the time of writing, due to imperfect polyfills, CSS still bleeds in both directions in Firefox and Edge. For us this is not catastrophic because we already avoid most CSS namespace collisions by using BEM syntax when naming our own component styles. Remaining potential issues with third party styles used inside components will disappear once all browsers natively support Standard Web Components. Read <a href='https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/' target='_blank'>https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/</a> to lean how to use BEM; it is a best practice even when not using components. See /topseed-webcomps/_webComp/circle.pug for an example of BEM inside a component. You can also attempt to insulate component CSS by using a scope div (see use of .bgauge-el in /topseed-webcomps/_webComp/gauge.pug) It is also possible to write components that bleed &#39;on purpose&#39;, by making components use actual DOM vs shadow DOM. You may choose to do this if you have a well-managed, globally applicable CSS regime (ideally using BEM throughout), and are not worried about 3rd party style bleeding. Or you can use SASS to bring global CSS styles into the component, analog to using mainA.css inline with AMP as shown in tutorial 5.</p>
</li>
<li><p>In a browser, go to the dashboard page at <a href='http://localhost:9081/page/dashboard/' target='_blank'>http://localhost:9081/page/dashboard/</a>. Inspect the dashboard page at /demo-srv/root/page/dashboard/index.pug for an example of using multiple components in one page. Find the reused &#39;list-el&#39;, as well as &#39;circle-el&#39; and &#39;gauge-el&#39; in the HTML. Inspect &#39;script.&#39; &#39;function UIinit&#39;. Note that The circle and gauge components are loaded from absolute URLs. This means that components can easily be shared across different web projects. In this example, ListBusiness is also used as the component communication &#39;message bus&#39; (The message bus features are found in BLX, the base class for ListBusiness.) &#39;sb.addComp&#39; connects each component to the bus, as long as the component implements a function named &#39;init&#39;. (The non-dashboard examples didn&#39;t call sb.addComp because their components did not send or receive messages.) Because ListBusiness was already present for loading list data, it was convenient to use it as message bus as well. if you prefer, you can use a separate message bus instead. See the use of &#39;const _blx = new BLX(null)&#39; at /demo-srv/root2/comp/com/index.pug</p>
</li>
<li><p>On the dashboard page at <a href='http://localhost:9081/page/dashboard/' target='_blank'>http://localhost:9081/page/dashboard/</a>, click on one of the list links see how the circle and gauge display values change. Repeat for each list item. The list component has detected that it is enabled to communicate and has pushed hidden list data (values for circle and gauge) to the bus (rather than just opening a new tab). Because circle and gauge components are also registered with the bus, they receive the values and use their component-specific implementation to update the display. This way, components are very loosely coupled. </p>
</li>
<li><p>Optional: Learn about the component communication implementation. First inspect the function &#39;addComp&#39; at /demo-srv/root/page/list/ListBusiness.js. It injects the bus into the component. Look at the &#39;ListEl.init&#39; function in /demo-srv/root/_webComps/List.pug. The component instance &#39;listEl&#39; keeps a reference to the bus. In the same file, look for the &#39;text/x-dot-template&#39; and see how &#39;listEl.nav&#39; is triggered when the user clicks on the link. Inspect the function definition &#39;ListEl.nav&#39;. It sends the data to the bus using key &#39;mySelection&#39;; see &#39;blx.emit(&#39;mySelection&#39;. In the Circle component implementation at /topseed-webcomps/_webComp/circle.pug, find function &#39;CircleEl.init&#39; (the equivalent of &#39;ListEl.init&#39; for the Circle web compoment). In &#39;_blx.on(&#39;mySelection&#39;,..&#39; it specifies to update the component display when the bus received a message with key &#39;mySelection&#39;. In summary, the components are &#39;loosely coupled&#39; because neither component requires the presence of other components. </p>
</li>
<li><p>We like creating and using components when it make us more productive, and the code becomes more maintainable. We decide this per use case. Be your own judge! </p>
</li>
<li><p>We&#39;re happy to provide inhouse seminars and workshops on the techniques shows in these Labs on request. Just email us at hi@appthings.io.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-10-mobile-app-phonegap-">Lab 10: Mobile App (Phonegap)</h2>
<ol>
<li><p>In this Lab we will customize and install an Android app that uses the Cordova In-App Browser to provide a rich UI. Download and unzip topseed-mobile-master.zip from <a href='https://github.com/topseed/topseed-mobile' target='_blank'>https://github.com/topseed/topseed-mobile</a> to your location of choice on your developer machine. Open the project in VS Code. Download, install and run the Phonegap Desktop App from <a href='https://github.com/phonegap/phonegap-app-desktop/releases' target='_blank'>https://github.com/phonegap/phonegap-app-desktop/releases</a>. In Phonegap Desktop, add the &#39;/topseed-mobile&#39; folder as a Project, and click the &#39;&gt;&#39; button. A message &#39;Server is running on ...&#39; should come up. Click on the URL to open the App in a browser. Resize the browser to mobile phone format. </p>
</li>
<li><p>The app is configured to show a splash screen and then display content obtained from https://m.appthings.io. We will make it display the content you published to the CDN in Lab 3 instead. As you edit the project, the Phonegap Desktop App watches for changes in the /www folder of the project and attempts to refresh the browser view on each change. In /www/js/index.js, replace the URL following &#39;window.open&#39; with the homepage URL of the helloworld app you deployed in Lab 3, i.e. your equivalent of &#39;https://staging.mydomain.com/page/one/index.html&#39;. If you only deployed to the CDN or zeit.co, use your equivalent of &#39;https://1234567890.rsc.cdn77.org/page/one/index.html&#39;. or &#39;https://demos-oosnsyzlphl.now.sh/page/one/index.html&#39;. If you never deployed, you can use the published version of this tutorial at &#39;https://docs.topseed.io/tutorial/0-agenda/index.html&#39;. We include &#39;/index.html&#39; in the path to ensure we deliver the turbo (non-AMP) version of the page.</p>
</li>
<li><p>To allow the in-app browser to navigate to the newly configured URL, in /config.xml &lt;allow-navigation href=&quot;https://m.appthings.io/*&quot; /&gt;, replace &#39;m.appthings.io&#39; with your equivalent from the previous step. The app should now display your site at the 
Phonegap Desktop App Server URL. It is a labor of love to replace the splash screen logo (at /www/css/index.css) and the icons used by the phone operating system (see /config.xml &#39;icon&#39; values) with your own; we will skip over it here. Optional: change the values for the app &#39;name&#39; and &#39;version&#39; in /config.xml.</p>
</li>
<li><p>To install the customized app on an Android phone, 
first create a zip file of the contents of the project folder /topseed-mobile. Create an account and login at <a href='https://build.phonegap.com' target='_blank'>https://build.phonegap.com</a>. 
On the &#39;Apps&#39; tab at <a href='https://build.phonegap.com/apps' target='_blank'>https://build.phonegap.com/apps</a>, click the &#39;+ new app&#39; button and upload the zip file (If your project is in Github, you can use the github clone URL instead). The site will take a few moments to build the app. Meanwhile, also log into <a href='https://build.phonegap.com' target='_blank'>https://build.phonegap.com</a> on your mobile phone. Once the build has completed, on your phone download, install and run the version for your phone&#39;s operating system (here: Android). Follow the installation prompts. Done! For fun, close the app and reopen it by tapping on the app icon on your phone UI.</p>
</li>
<li><p>See <a href='http://docs.phonegap.com/' target='_blank'>http://docs.phonegap.com/</a> for further information about phonegap, for instruction how to deploy to Apple iOS,and how your app can access phone-specific APIs, such as address book, location information etc if necessary. We would use a &#39;service worker&#39; to support offline-browsing as needed.</p>
</li>
<li><p>In this Lab, we have used the Cordova In-App Browser to render app content from a CDN. As shown in Lab 6, the app can also obtain data securely from separate API servers. Thanks to appshell, Turbo and caching introduced in Lab 4, the app has a smooth &#39;single page application&#39; feel. As a result, we were able to develop a rich mobile app without requiring special Android SDK/iOS development skills. </p>
</li>
</ol>
