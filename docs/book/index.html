
<h4>Web App Front-End Development Best Practices 2017 - A Lab Book</h4>
<p>new-page</p><p><em>If we complicate things, they get less simple.</em>
- Professor at Cambridge University</p>
<p><em>... Simplifications have had a much greater long-range scientific impact than individual feats of ingenuity. The opportunity for simplification is very encouraging, because in all examples that come to mind the simple and elegant systems tend to be easier and faster to design and get right, more efficient in execution, and much more reliable than the more contrived contraptions that have to be debugged into some degree of acceptability ... Simplicity and elegance are unpopular because they require hard work and discipline to achieve and education to be appreciated.</em>
- Edsger W. Dijkstra</p>
<p><em>Complexity is a sign of technical immaturity. Simplicity of use is the real sign of a well designed product whether it is an ATM or a Patriot missile.</em>
- Daniel T. Ling</p>
<p><em>Simplicity is the soul of efficiency.</em>
- Austin Freeman, &#39;The Eye of Osiris&#39;</p>
<p><em>La perfection est atteinte non quand il ne reste rien à ajouter, mais quand il ne reste rien à enlever.</em>
[Perfection is not achieved when nothing needs to be added, but when there is nothing left to remove.]
- Antoine de Saint-Exupéry</p>
<p><em>Controlling complexity is the essence of computer programming.</em>
- Brian Kernighan</p>
<p><em>Der Unterschied zwischen einem guten und einem schlechten Architekten besteht heute darin, daß dieser jeder Versuchung erliegt, während der rechte ihr standhält.</em>
[The difference between a good and a bad architect today is that one yields to every temptation, while the right one resists it.]
- Ludwig Wittgenstein</p>
<p><em>Simplicity does not precede complexity, but follows it.</em>
- Alan J. Perlis </p>
<ul>
<li></li>
</ul>

<p>new-page</p>
<h3>Wolfgang Gehner</h3>
<p></p>
<h1>Web App Front-End Development Best Practices 2017 </h1>
<h3>A Lab Book </h3>
<p>(Check docs.topseed.io/tutorial for a current online version)</p>
<p>Kindly supported by: appthings.io</p>
<p>new-page</p>
<p>1st Edition 2017</p>
<p></p>
<p>Copyright &copy; Wolfgang Gehner (wgehner@gmail.com)</p>
<p>Contact hi@appthings.io for rights to reproduce this book in any form.  </p>
<p>In almost all cases, code is licensed under the MIT license. Check https://cdn.jsdelivr.net/gh/topseed/topseed/LICENSE.md for exceptions.</p>
<p>new-page</p><p>Special thanks to Red Cap Development, LLC (appthings.io) for sponsoring the production of this book.</p>

<p>new-page</p>
<h3>Table of Contents</h3>
<p></p>
<h3>Part I: The Basics</h3>
<h3>Part II: The Bricks and Mortar</h3>
<h3>Part III: The Perspectives</h3><h2 id="agenda-">Agenda:</h2>
<p>The Foundation</p>
<ul>
<li><p><a href="./1-helloWorld/">1: Hello World - Using Markdown with Preprocessor</a></p>
</li>
<li><p><a href="./2-theBasics/">2: Material Design, SASS and Pug</a></p>
</li>
<li><p><a href="./3-goLive/">3: Go-Live - Deploy to Cloud and Use a CDN</a></p>
</li>
<li><p><a href="./4-appShell/">4: AppShell, Turbo and Caching for Performance</a></p>
</li>
</ul>
<p>The Bricks and Mortar</p>
<ul>
<li><p><a href="./5-read/">5: UI Reading from an API</a> </p>
</li>
<li><p><a href="./6-write/">6: UI Writing to an API (Example: Firebase)</a> </p>
</li>
<li><p><a href="./7-security/">7: Log-in Security and Tokens</a></p>
</li>
<li><p><a href="./8-mobile/">8: Mobile App (Phonegap)</a></p>
</li>
</ul>
<p>The Perspectives</p>
<ul>
<li><p><a href="./9-comps/">9: Standard Web Components and their Communication</a></p>
</li>
<li><p><a href="./10-ssr/">10: NEW! Server-side rendering (SSR) of Web Components</a></p>
</li>
<li><p><a href="./11-amp/">11: Accelerated Mobile Pages (AMP)</a></p>
</li>
</ul>

<p>new-page</p>
<h2>Part I: The Basics</h2>
<p>new-page</p><h2 id="lab-1-hello-world-using-markdown-with-preprocessor">Lab 1: Hello World - Using Markdown with Preprocessor</h2>
<ol>
<li><p>Download and unzip <code>topseed-helloworld-master.zip</code> from <a href='https://github.com/topseed/topseed-helloworld' target='_blank'>https://github.com/topseed/topseed-helloworld</a> to your location of choice on your developer machine.</p>
</li>
<li><p>Open your Google Chrome web browser and install the &#39;Web Server for Chrome&#39; app from <a href='https://chrome.google.com/webstore/search/Web%20Server?_category=apps' target-'_blank'>https://chrome.google.com/webstore/search/Web%20Server?_category=apps</a>. Launch the app, click the &#39;Choose Folder&#39; button and select the folder <code>/public</code> under <code>/topseed-helloworld/topseed-helloworld-io</code>. Also ensure &#39;Options&#39; has &#39;Automatically show index.html&#39; checked. Ensure the Web Server is <em>STARTED</em>, then navigate to the proposed URL (e.g. <a href='http://127.0.0.1:8887' target='_blank'>http://127.0.0.1:8887</a>). You should see a demo website. Explore the site. It uses <em>responsive design</em>; resize the browser from fullscreen to narrow to see the layout adapt. </p>
</li>
<li><p>Download, install and run &#39;Visual Studio Code&#39; (VS Code) from <a href='https://code.visualstudio.com/download' target='_blank'>https://code.visualstudio.com/download</a>. From &#39;File&#39; menu, choose &#39;Open Folder...&#39; and select folder <code>/topseed-helloworld</code>. When the project is loaded, inspect the default entry page at <code>/topseed-helloworld-io/public/index.html</code>. We like VS Code, but you can use any other editor of your choice.</p>
</li>
<li><p>Download, install and run Prepros (Unlimited Trial) from <a href='https://prepros.io/downloads' target='_blank'>https://prepros.io/downloads</a>. Use the &#39;+&#39; button on the bottom left to add the folder <code>/topseed-helloworld</code> as a new project. In Project/Settings/Compiler Settings/Markdown, uncheck &#39;Wrap with HTML&#39;.</p>
</li>
<li><p>In the browser, return to the home page (e.g. <a href='http://127.0.0.1:8887' target='_blank'>http://127.0.0.1:8887</a>). In VS Code, open <code>/public/page/one/_hello.md</code> and prefix the text with &#39;Hello World!&#39; Save the file. In the same folder, inspect _hello.html. Prepros will have <em>preprocessed</em> your edited <em>markdown</em> file to HTML. Refresh the browser and see the edits. Search Google for &#39;Markdown syntax&#39;.</p>
</li>
<li><p>Optional: Use Prepros to auto-refresh on edits. In Prepros, click on the arrows on the right side of the Prepros project name &#39;topseed-helloworld&#39;, check &#39;Sync Browsers&#39; and click &#39;Preview&#39; (or rightclick on &#39;topseed-helloworld&#39; and select &#39;Open Live Preview&#39;). A browser should open and display the home page. In VS Code, edit and save <code>_hello.md</code> again. The opened browser should refresh and include your changes.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-2-the-basics-material-design-sass-and-pug">Lab 2: The Basics - Material Design, SASS and Pug</h2>
<ol>
<li><p>Ensure you have the sample project topseed-helloworld open in VS Code and Prepros running on it. Per <a href="./1-helloWorld/">Lab 1</a>, make sure the home page is running in a browser.</p>
</li>
<li><p>Visit and browse these sites: <a href='http://materialpalette.com' target='_blank'>http://materialpalette.com</a>, <a href='https://design.google' target='_blank'>https://design.google</a>, <a href='https://material.io' target='_blank'>https://material.io</a> and
<a href='https://material.io/guidelines/#' target='_blank'>https://material.io/guidelines/#</a>. We follow <em>Material Design</em> guidelines, put forward by Google, to make our sites and mobile apps look better. </p>
</li>
<li><p>Find <code>&#39;/_sass/main.css&#39;</code> in the home page source, and inspect it. Other than fonts, all CSS used on the site is in this one CSS.</p>
</li>
<li><p>Visit <a href='https://www.muicss.com' target='_blank'>https://www.muicss.com</a>. Read &#39;Getting Started/Introduction&#39;, then browse the section &#39;CSS/JS&#39;. We use the MUI CSS libraries in our project. Inspect <code>/public/_sass/_base.scss</code>. SCSS is CSS with some added features, such as <code>$variables</code> and <code>@import</code>. You can turn any CSS file into SCSS just by changing the ending to <code>.scss</code>.</p>
</li>
<li><p>Inspect <code>/public/_sass/_colors.scss</code>. See a color scheme we generated with materialpalette.com. Use /* */ to comment it out. Go back to <a href='http://materialpalette.com' target='_blank'>http://materialpalette.com</a>, pick two colors, download your own palette in CSS format and paste it after the section you commented out. Save, refresh the browser; you should see your new color scheme applied to the site. Revert to the palette you had commented out.</p>
</li>
<li><p>Inspect <code>/public/_sass/main.sass</code>. <em>SASS</em> uses a special syntax without the curly braces or <code>&#39;;&#39;</code> at the end of a line that are used in CSS (and SCSS). SASS can also use SCSS imports such as <code>@import &#39;_base&#39;</code>. Prepros compiles the <code>.sass</code> and its dependent <code>.scss</code> imports into the single <code>main.css</code> used in the browser. In Prepros Files select _main.sass, check &#39;Minify CSS&#39;, and click Process File. Open <code>/_sass/main.css</code> and see that it is now minified.</p>
</li>
<li><p>Inspect <code>/page/two/_buttons.html</code>. Copy the entire HTML. Go to <a href='http://html2jade.org' target='_blank'>http://html2jade.org</a> (Pug used to be called Jade) and paste this html. In the right pane you see <em>Pug</em> markup, a way to write html without having to worry about closing tags. We write Pug. </p>
</li>
<li><p>Inspect the code snippet at <code>/page/two/_buttons.pug</code>. It should match the output of html2jade. Every <code>.pug</code> file in the project has a corresponding <code>.html</code> used by the browser, with the exception of include&#39;s within another <code>.pug</code> file. Inspect <code>/page/two/index.pug</code> to find the <code>&#39;include _buttons&#39;</code>. Inspect <code>/page/two/index.html</code> to find the generated buttons HTML.</p>
</li>
<li><p>Watch the video &#39;Do you Even JADE bro&#39; at <a href-"https://www.youtube.com/watch?v=wzAWI9h3q18" target="_blank">https://www.youtube.com/watch?v=wzAWI9h3q18</a>. Once you know how to write Pug, you can generate beautiful HTML quickly.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-3-go-live-deploy-to-cloud-and-use-a-cdn">Lab 3: Go-Live - Deploy to Cloud and use a CDN</h2>
<ol>
<li><p>Go to <a href='https://zeit.co'target='_blank'>https://zeit.co</a> and create a free account. We use their &#39;NOW&#39; product to deploy our apps for testing in the cloud. Install the &#39;NOW&#39; client.
Instead, you could zip up the folder <code>/public</code> and deploy to any
static web hosting service via FTP. However, we will need some &#39;dynamic&#39;, server-side features later, so we wrap our static webroot content with some code that works on a Node.js server, such as used by &#39;NOW&#39;.
Rename <code>/public/cache.mfx</code> to <code>cache.mf</code>.</p>
</li>
<li><p>To deploy to zeit.co: With the project &#39;topseed-helloworld&#39; open in VS Code, open a Terminal Shell by selectingg menu View-Integrated Terminal (or pressing <code>`(Ctrl+Shift+</code>)In the console that opens, change directory with <code>&#39;cd helloworld-topseed-io [Enter]&#39;</code> and then trigger the zeit.co deployment by typing <code>&#39;now [Enter]&#39;</code>. Follow the prompts. (For advanced users: this folder includes <code>index.js</code> and <code>package.json</code> needed by Node.js.) When the console shows &#39;Ready!&#39;, click on the URL that follows while holding the <code>&#39;[Ctrl]&#39;</code> key to open a browser. Once deployment is completed, the app will display. Bookmark the URL. You are in the Cloud and live on the Web!</p>
</li>
<li><p>To run the project in Node on your machine (you will need this for tutorials that follow): Install Node.js and NPM. If you have a Mac, follow the instructions at <a href-'http://blog.teamtreehouse.com/install-node-js-npm-mac' target='_blank'>http://blog.teamtreehouse.com/install-node-js-npm-mac</a>. If you have Windows, download and run the installer from <a href='https://nodejs.org/en/download/' target='_blank'>https://nodejs.org/en/download/</a>, accept the default settings, and restart your computer. Reopen the project &#39;topseed-helloworld&#39; in VS Code. Select menu View-Integrated Terminal. On the command line that opens, change directories with <code>&#39;cd helloworld-topseed-io&#39;</code>. To test Node, type <code>&#39;node -v&#39;</code> and hit <code>Enter</code>. You should see a version number like <code>v8.0.0</code>. To test NPM, type <code>&#39;npm -v&#39;</code> and hit <code>Enter</code>. You should see a version number like <code>4.0.3</code>. Use Google to troubleshoot the install of Node and NPM for your operating system if necessary. </p>
</li>
<li><p>You are almost ready to run the app in Node. First you will use NPM to download the <em>dependencies</em> listed in <code>/package.json</code>. Go back to the Terminal Shell, make sure you are in the <code>/helloworld-topseed-io</code> directory, then type <code>&#39;npm install&#39;</code> and hit <code>Enter</code>. This will install the dependencies in a <code>/node_modules</code> directory. It will take a while, but the console will tell you when done. (Repeat this step when you add a dependency yourself.)</p>
</li>
<li><p>Inspect <code>/helloworld-topseed-io/index.js</code>. This is the JavaScript file that starts the app, including an <code>&#39;express&#39;</code> HTTP server. Return to the Terminal Shell (still in the <code>/helloworld-topseed-io</code> directory) and type <code>&#39;node index&#39;</code> (you can omit the <code>.js</code>) and hit <code>Enter</code> to start the app. You should see output like &#39;App listening at <a href="http://localhost:8888">http://localhost:8888</a>&#39;. (To stop it, you would press <code>Ctrl+C</code>). Click on the URL that follows while holding the <code>&#39;[Ctrl]&#39;</code> key to open a browser.</p>
</li>
<li><p>Read the remainder of this tutorial. Execute the steps if you are preparing for QA/Staging/Production. To give your site a &#39;proper&#39; domain, you will need a domain name and DNS. If you do not have a domain yet, we recommend to register a cheap domain at <a href='https://www.namecheap.com/' target='_blank'>https://www.namecheap.com</a> now and have it use the namecheap DNS.
If you already own a domain and host a site, e.g. at <code>www.mydomain.com</code>, you may want to configure a CNAME to map a <code>&#39;staging.&#39;</code> subdomain, such as <code>staging.mydomain.com</code>, so you can keep using <code>&#39;www.&#39;</code> for your public site. See below for more detailed instructions. </p>
</li>
<li><p>For scalability and caching, you will also want to use a Content Delivery Network (CDN). With a CDN, you also get SSL/HTTPS for free. No need to buy an expensive SSL certificate. SSL is important when using advanced Javascript functions in the browser, such as cross-domain data requests. We recommend <a href='https://www.cdn77.com' target='_blank'>https://www.cdn77.com</a>. For this tutorial, register for the CDN77 14-day free trial now.</p>
</li>
<li><p>In the CDN77 web app, go to menu item CDN and click &#39;ADD NEW CDN RESOURCE&#39;. Give it a label, such as &#39;staging.mydomain.com&#39; and select &#39;My Origin&#39;. As domain, specify HTTPS and the <code>zeit.co</code> DOMAIN from the URL you bookmarked under 2. (e.g. topseed-helloworld-oosnsyzlphl.now.sh). Click &#39;CREATE CDN RESOURCE&#39;.</p>
</li>
<li><p>Choose 4-step setup with CNAME. Click &#39;Add new CNAME&#39;, and &#39;+ ADD CNAMES&#39;. Enter &#39;staging.mydomain.com&#39; and Click &#39;ADD CNAME&#39;. Click &#39;Go back to Integration&#39;. In Step 2, copy the DOMAIN NAME (AKA HOST), e.g 1234567890.rsc.cdn77.org, then follow instructions for your hosting provider. If your domain is with namecheap.com, do the following:
On the Namecheap dashbord, click &#39;Manage&#39; for your domain, and &#39;Advanced DNS&#39;. Click &#39;ADD NEW RECORD&#39;, select &#39;CNAME&#39; and enter the following: Host: staging Value: [DOMAIN NAME from clipboard, e.g. 1234567890.rsc.cdn77.org], TTL: Automatic. Click the checkmark to save. No need to do CDN77 Step 3. One final step is to go to the &#39;Other Settings&#39; tab, check &#39;HTTPS redirect&#39; and click &#39;SAVE CHANGES&#39;.</p>
</li>
<li><p>After an hour after the initial setup, you should be able to reach the deployed site in your browser under e.g. <a href='https://staging.mydomain.com' target='_blank'>https://staging.mydomain.com</a>. Note the use of <code>&#39;https&#39;</code>. If you visit too quickly, the browser will complain that the site certificate is invalid. If this happens, try again after a while. The CDN caches static files for greater performance in multiple distributed datacenters. For advanced users: Review <code>/topseed-srv/util/Decider.js</code>. Find uses of <code>&#39;U.cache&#39;</code>; this sets <em>Cache-Control</em> response headers which tell th CDN how long to keep content before refreshing it from the source. The utils library &#39;U&#39; is included in the project <a href="https://github.com/topseed/topseed-npm">https://github.com/topseed/topseed-npm</a>, deployed to <em>npmjs</em>, and imported to the project through a &#39;package.json&#39; dependency. </p>
</li>
<li><p>Edit <code>/public/page/one/_hello.md</code> again (see Lab 1: 5.). To deploy the change, follow step 2 above. In CDN77 Overview, change &#39;What is your domain?&#39; to the new URL, and click &#39;SAVE CHANGES&#39;. To make the changes appear on the CDN edge servers immediately, use CDN77 &#39;CDN/Purge&#39; on /page/one/.</p>
</li>
<li><p>Optional: Once you are ready to move from staging to production, you would either edit the CNAME for www to point to the same CDN domain (e.g. <code>1234567890.rsc.cdn77.org</code>) or add a new CDN resource such as <code>www.mydomain.com</code> that may also use a new <code>zeit.co</code> domain created when redeploying the app to <code>zeit.co</code> &#39;NOW&#39; (see step 2. above).</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-4-appshell-turbo-and-caching-for-performance">Lab 4: AppShell, Turbo and Caching for Performance</h2>
<ol>
<li><p>Inspect <code>/public/page/one/index.pug</code> and <code>/page/two/index.pug</code>. These Pug files show how the parts of the HTML they have in common are pulled from central places. Both pages use or &#39;extend&#39; the <em>template</em> <code>_part/_baseShell.pug</code>. Open this template file, and see that it has &#39;blocks&#39; named <code>&#39;head&#39;</code>, <code>&#39;main&#39;</code>, and <code>&#39;footer&#39;</code>. The Pug pages that extend this template define how to replace these blocks. For example,<code>/page/one/index.pug</code> defines that the <code>&#39;head&#39;</code> block consists of a page-specific <code>&#39;title&#39;</code> tag and an included <em>fragment</em> <code>_part/_header.pug</code>. We re-use <code>_header.pug</code> in <code>/page/two/index.pug</code>.</p>
</li>
<li><p>Inspect <code>/public/_part/_top.pug</code>. This fragment represents the top menu and side drawer used on all pages. You can find it referenced in <code>/_part/_baseShell.pug</code> as <code>&#39;include _top&#39;</code>. Now inspect <code>/page/one/index.html</code>. This is the complete HTML which Prepros has collated together from template and fragments. Since the server has been configured to return the &#39;default&#39; page <code>index.html</code> when the browser requests <code>/page/one/</code>, this is what the end user sees. </p>
</li>
<li><p>You have seen that a pug template or fragment can include other pug fragments. It can also include a fragment which is already in HTML format, such as <code>/page/one/_hello.html</code> included in <code>/page/one/index.html</code>. The file <code>_hello.html</code> is the result of processing the markdown file <code>_hello.md</code>. We find that Pug is not only a great way to write clean HTML, it is also very useful for defining layouts and reusing page elements.</p>
</li>
<li><p>To give the application a <em>Single-Page Application feel</em>, we use an optional JavaScript library called topseed-turbo (&#39;TT&#39;). When a user navigates from one URL to the next, TT replaces only the part of the HTML body that is unique to each page (The section marked &#39;#content-wrapper&#39; in <code>_baseShell.pug</code> and <code>/_js/main.js</code>). TT is unobtrusively loaded by JavaScript included in the <code>_header.pug</code> section (<code>/setup-x.x.js</code>). Using TT avoids &#39;page flash&#39; and makes for smoother navigation, very similar to a native <em>rich client app</em> where only individual panels are replaced on navigation. Smoother navigation increases the <em>perceived performance</em> of the application.</p>
</li>
<li><p>Optional: Advanced JavaScript users may be interested to look at <code>TS.onAppReady(UIinit)</code> in <code>/page/one/index.pug</code>. TS stands for &#39;topseed-setup&#39;. TS receives an event when the <code>#content-wrapper</code> HTML is fully present in the browser (similar to a &#39;pageLoaded&#39; event). When using Turbo (TT), <code>TS.onAppReady</code> provides an important hook for page-specific JavaScript that requires the DOM to be fully initialized.</p>
</li>
<li><p>Rename <code>/public/cache.mfx</code> to <code>/cache.mf</code> and inspect it. The <em>AppCache</em> is a good way to improve performance of a web application. The file is referred to as <em>manifest</em> in <code>_part/_baseshell.pug</code>.  If the manifest file is present, the browser will keep its listed resources in the browser cache &#39;forever&#39;, and serve them from there, without going to the network, until the <code>cache.mf</code> file itself changes. You can see what the browser does with the AppCache if you run a page in Developer mode (hit <code>Ctrl-Shift+i</code> and select the &#39;Console&#39; tab in your Chrome browser). For development, we disable the AppCache by renaming it from <code>.mf</code> to <code>.mfx</code>. If you ever suspect the browser having cached an older version of a resource, right-click the refresh button on the left of the URL in the Chrome browser (with Developer Console open) and select &quot;Empty Cache and Hard Reload&quot;.</p>
</li>
<li><p>We also achieve performance gains by setting response headers in <code>Decider.js</code> to allow caching of content at the CDN <em>edge</em> as described in tutorial 3.</p>
</li>
</ol>

<p>new-page</p>
<h2>Part II: The Bricks and Mortar</h2>
<p>new-page</p><h2 id="lab-5-accelerated-mobile-pages-amp-">Lab 5: Accelerated Mobile Pages (AMP)</h2>
<ol>
<li><p><em>AMP</em> is a way to ensure that web pages render fast on mobile devices, for a better user experience (UX). Visit and browse <a href='https://www.ampproject.org/learn/overview/' target='_blank'>https://www.ampproject.org/learn/overview/</a> to learn more about AMP. Other than fast rendering, one advantage of AMP pages is that Google will cache AMP pages for you for free. There are some restrictions as to what a valid AMP page can include (such as no custom JavaScript), but it allows you to use the full power of CSS. Download and unzip <code>topseed-master.zip</code> from <a href='https://github.com/topseed/topseed' target='_blank'>https://github.com/topseed/topseed</a> to your location of choice on your developer machine. We use the &#39;dynamic&#39;, server-side features of Node.js to help with serving AMP pages where appropriate. It is, however, possible to create a completely static site that serves AMP. In this tutorial, we show how both AMP and non-AMP versions can share common resources to limit content duplication.</p>
</li>
<li><p>If you have not installed Node.js on your machine, follow the instructions in tutorial 3 to install it. Then select menu View-Integrated Terminal. On the command line that opens, change directory with <code>&#39;cd demo-topseed-io&#39;</code>. Type <code>&#39;npm install&#39;</code> and hit <code>Enter</code>. Once complete, type <code>&#39;node index [Enter]&#39;</code>.</p>
</li>
<li><p>In a browser, go to <a href='http://localhost:8092' target='_blank'>http://localhost:8092</a> and see /page/one/ come up. Rightclick on the page to &#39;Show HTML source&#39;. You will note that the <code>head</code> tag has AMP-specific content. To compare, review the HTML source or the non-AMP version at <code>localhost:8091</code>.
In production, we would likely map port 8091 to <code>www.mydomain.com</code> and port 8092 to <code>m.mydomain.com</code>. Behind the scenes, we have a Node module at <code>/server/util/Decider.js</code>. The function of <code>Decider</code> with regard to AMP is twofold: (a) if a request of <code>/page/one/</code> is on the first port, it will return the HTML from <code>/page/one/index.html</code>; if the request is on the second port, it will return the HTML from <code>/page/one/indexA.html</code>. (b) it will attempt to return the alternate version if the requested one does not exist, no matter what port the request arrived on. You can change port numbers in <code>/config/ServerConfig.js</code> (restart with &#39;node index&#39;).</p>
</li>
<li><p>Let us inspect how AMP pages are composed differently, but share some resources. Inspect <code>/page/one/indexA.pug</code>. Our convention is to post-fix AMP-specific resources with a capital <code>&#39;A&#39;</code>. See how <code>/indexA.pug</code> uses <code>_baseShellA.pug</code> and <code>_headerA.pug</code>, but uses the same <code>_footer.pug</code> as non-AMP <code>/index.pug</code>.
Likewise, both <code>/index.pug</code> and <code>/indexA.pug</code> share the use of <code>_hello.html</code>.
<code>indexA.pug</code> also has a required &#39;canonical&#39; link that points to the non-AMP version of the resource. Also note that <code>/indexA.pug</code> does not have the <code>&#39;script&#39;</code> element, since AMP does not permit custom JavaScript. AMP has some custom tags/components to help building AMP pages; see <a href='https://www.ampproject.org/docs/reference/components' target='_blank'>https://www.ampproject.org/docs/reference/components</a>. For example, JavaScript <em>is</em> allowed inside an <code>amp-iframe</code> (example at <a href='https://m.appthings.io' target='_blank'>https://m.appthings.io</a>). </p>
</li>
<li><p>Inspect <code>/_part/_baseShellA.pug</code>. It <em>includes</em> <code>&#39;_topA.pug&#39;</code>, which is a non-JavaScript version of <code>&#39;_top.pug&#39;</code> that uses the <code>&#39;#sidedrawer</code>&#39; anchor combined with CSS to obtain the slide-out functionality without JavaScript. Also inspect <code>/_part/_headerA.pug</code>. It includes <code>&#39;../_sass/mainA.css&#39;</code> inside a <code>&#39;style(amp-custom=&#39;&#39;)&#39;</code> tag. This means that the CSS for AMP is served inline rather than from a separate request. <code>mainA.sass</code> has the same content as <code>main.sass</code>, but having a separate file for <code>mainA</code> allows us to compress or <em>mininize</em> it (we use Prepros on the individual file) for inline use, since AMP files have a total size limitation.</p>
</li>
<li><p>Both AMP and non-AMP versions have the same responsive design features: they adapt to screen size. The AMP version should just be served faster, as optimized and privileged by Google caching. This may be especially important for the home page, where you do not want to let the user wait unnecessarily for the page to render. For custom behavior, you can force the <em>non</em>-AMP version by using the whole path <code>/page/one/index.html</code> in links or in the browser. We could make all <code>&#39;a href&#39;</code> links in the app to go to non-AMP versions by adding <code>/index.html</code> to them. We usually do this to take advantage of the (JavaScript-based) Topseed Turbo feature that provides for a smoother single-page application feel.</p>
</li>
<li><p>In summary, the app supports fast AMP responses but provides for non-AMP fallback versions where necessary. For example, a &#39;Contact Us&#39; page that uses JavaScript to validate submissions would not have an AMP version. <code>Decider.js</code> on the server-side helps to automatically serve the available version.</p>
</li>
<li><p>You can use an AMP validator to ensure your AMP is valid; see <a href='https://validator.ampproject.org' target='_blank'>https://validator.ampproject.org</a>. Your markup has to be valid to be indexed and cached by Google. If your page is online, you can re-validate and submit it at <a href='https://search.google.com/search-console/amp' target='_blank'>https://search.google.com/search-console/amp</a>.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-6-ui-reading-from-an-api">Lab 6: UI Reading from an API</h2>
<ol>
<li><p>For this and the <a href="./7-write/">next lab</a>, we work on an &#39;Admin&#39; module that allows listing (and adding to) a &#39;Linkblog&#39;, or list of links. In a browser, go to <a href='http://localhost:8091' target='_blank'>http://localhost:8091</a> and click on the &#39;Admin&#39; menu item to navigate to the &#39;Topseed Admin Console&#39; (We will add login security in tutorial 8). The Admin module has its own appshell and menu (see <code>/_part/admin/</code>). To signal a full screen refresh to turbo, we added a <code>&#39;#&#39;</code> to the link that leads to the Admin home screen at <a href='http://localhost:8091/admin/home/#' target='_blank'>http://localhost:8091/admin/home/#</a>. The refresh ensures that the standard menu (which would otherwise remain &#39;cached&#39; and re-displayed) is replaced by the Admin menu. </p>
</li>
<li><p>Click on the &#39;Linkblog&#39; menu item at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>to navigate to a list of linkblog items. Rather than composing a screen in full on a server, modern web apps often take a HTML page to the browser first and then let the browser call an API to &#39;fill in&#39; the data, using JavaScript. This way, the static elements of a page can be served by a fast CDN, and the dynamic/data parts can be obtained directly from the data source.</p>
</li>
<li><p>The linkblog list is populated with data coming from a <em>JSON</em> response to an API call. By default, the tutorial project is configured to obtain the API response from a file at <code>/public/linkblog/dummy.json</code> or <a href='http://localhost:8091/linkblog/dummy.json' target='_blank'>http://localhost:8091/linkblog/dummy.json</a>. However, in the next tutorial we will call a real, live database API that resides on a separate API server. </p>
</li>
<li><p>Now click the &#39;Add Item&#39; button and note how the browser URL changed to <a href='http://localhost:8091/admin/linkblog/detail.html' target='_blank'>http://localhost:8091/admin/linkblog/detail.html</a>. This is a <em>stable URL</em> for the the data entry form to add/write a new item. &#39;Stable URL&#39; means that page is not lost when you hit the browser refresh button, and that the page is &#39;bookmarkable&#39;, which is almost always a good thing. For now, click &#39;Cancel&#39; to return to the list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>.</p>
</li>
<li><p>Inspect <code>/public/admin/linkblog/index.pug</code>. This file defines the composition of the linkblog list screen. In the &#39;HTML&#39; part of this file, the list is represented by the pug statement <code>&#39;table#grid&#39;</code> (<code>&#39;&lt;table id=&quot;grid&quot;&gt;&#39;</code>). The <code>&#39;script.&#39;</code> part of the file is responsible for causing the grid data to be loaded and rendered. The dot at the end of <code>&#39;script.&#39;</code> tells Pug to not convert what follows to HTML. </p>
</li>
<li><p>In <code>&#39;script.&#39;</code> we load external JavaScript that encapsulates logic, which keeps the page HTML clean and designer-friendly. In this example <code>&#39;TS.loadOnAppReady&#39;</code> loads <code>/admin/linkblog/LinkblogBusiness.js</code>, then calls the <code>&#39;UIinit&#39;</code> function in the page. This function triggers the <code>&#39;list&#39;</code> function of <code>LinkblogBusiness</code>, which asynchronously loads data from the API, and &mdash; once the data has been received &mdash; renders the grid as well as the data in the grid. Depending on how much data is to be loaded, a more advanced version of <code>LinkblogBusiness</code> could have a separate function (e.g. <code>&#39;init()&#39;</code>) to first render the grid without data, and the <code>&#39;list()&#39;</code> function would only load and render the list items.</p>
</li>
<li><p>Open <code>/public/admin/linkblog/LinkblogBusiness.js</code> and scroll to the end of the file. See how <code>LinkblogBusiness</code> wraps a <code>&#39;SimpleBusiness&#39;</code> object instance named <code>&#39;sb&#39;</code> that is returned to the page after we added a <code>LinkblogDao</code> <em>Data Access Object (DAO)</em> instance. The page-specific custom functionality of <code>SimpleBusiness</code> is added close to the top of the file, beginning with <code>&#39;var SimpleBusiness = BLX.extend({&#39;</code>. We keep common business functionality in a base <code>&#39;class&#39;</code> named <code>BLX.js</code> (&#39;BusinessLogiX&#39;), and common data service functionality in <code>BDS.js</code> (BaseDataService). Both are loaded by <code>/_js/admin.js</code>, the &#39;admin module version&#39; of <code>main.js</code>.</p>
</li>
<li><p>In <code>LinkblogBusiness.js</code> we use <code>&#39;var SimpleBusiness = BLX.extend({&#39;</code> instead of the more recent <code>&#39;class SimpleBusiness extends BLX {&#39;</code>, because Internet Explorer (IE) does not support &#39;class&#39;. However, Microsoft&#39;s &#39;Edge&#39; browser supports it. We will use &#39;class&#39; once IE has lost its remaining popularity; see <code>/admin/linkblog/LinkblogBusiness2.js</code> for an example. Note the resulting improvement in function signatures e.g. <code>&#39;list()&#39;</code> vs <code>&#39;,list: function()&#39;</code>. If you can exclude the use of IE (such as for an internal web-app or a mobile app) we recommend you use the &#39;class&#39; version. You can read more about the IE-compatible version at <a href='http://johnresig.com/blog/simple-javascript-inheritance' target='_blank'>http://johnresig.com/blog/simple-javascript-inheritance</a>. To use the &#39;class&#39; version, in this example you would use <code>TS.loadOnAppReady(&#39;/admin/linkblog/LinkblogBusiness2.js&#39;</code> in <code>/admin/linkblog/index.pug</code> and <code>/detail.pug</code> and change <code>/_js/admin.js</code> to load <code>BLX2.js</code> and <code>BDS2.js</code> instead of <code>BLX.js</code> and <code>BDS.js</code>.</p>
</li>
<li><p>In LinkblogBusiness.js, inspect the code section following <code>&#39;, list: function(listId)&#39;</code>. The JavaScript in <code>/admin/linkblog/index.pug</code> triggers this function with <code>&#39;sb.list(&#39;#grid&#39;)&#39;</code>. Brushing over the details of obtaining the data for now, this function receives a <code>&#39;_listPromise&#39;</code> of data from the configured API. When data is returned, the function <code>&#39;_renderList&#39;</code> enters <code>&#39;_listPromise.then(function(values){&#39;</code>, builds the grid with the received values (a JSON array of rows) and renders it in the page element with <code>id &#39;grid&#39;</code>. There are many ways to render lists. In this example we use <a href='https://dataTables.net/' target='_blank'>https://dataTables.net/</a> to deliver advanced grid sorting, searching and paging features. </p>
</li>
<li><p>JavaScript <em>promises</em> are a modern way to manage process flow. They are especially useful for handling asynchronous calls such as HTTP requests to an API that may require error handling, such as connection errors. They replace classic asynchronous callbacks that are prone to <em>&#39;Callback Hell&#39;</em>; see <a href='http://callbackhell.com' target='_blank'>http://callbackhell.com</a>.  A lot of public APIs, such as Google Firebase, use or allow the use of promises, and you can &#39;promisify&#39; those that don&#39;t. Promises are important, learn how they work at <a href='http://www.telerik.com/blogs/what-is-the-point-of-promises' target='_blank'>http://www.telerik.com/blogs/what-is-the-point-of-promises</a>. The post <a href='https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks' target='_blank'>https://stackoverflow.com/questions/22539815/arent-promises-just-callbacks</a> may also help.</p>
</li>
<li><p>The <code>LinkblogDao</code> Data Access Object is responsible for obtaining the raw list data. See <code>&#39;urlSpec&#39;</code> at the top of <code>LinkblogBusiness.js</code> and how <code>LinkblogDao</code> extends <code>BDS</code> (which contains common data access functionality). Also see at the bottom of <code>LinkblogBusiness.js</code> how <code>urlSpec</code> is passed to <code>LinkblogDao</code> with <code>&#39;sb.linkblogDao = new LinkblogDao(urlSpec)&#39;</code>. Unlike <code>SimpleBusiness</code>, in this case <code>LinkblogDao</code> has no added functionality, so we could write <code>&#39;sb.linkblogDao = new BDS(urlSpec)&#39;</code> instead.</p>
</li>
<li><p>Inspect <code>&#39;/_js/BDS.js</code> and its <code>&#39;selectList&#39;</code> function. It calls a shared static <code>&#39;_get&#39;</code> function which uses <code>&#39;fetch_&#39;</code> to call the <code>urlSpec</code> URL and returns a promise of the response content. <em>Fetch</em> is a modern replacement for Ajax/XMLHttpRequest. Fetch uses promises! Read more about Fetch at <a href='https://davidwalsh.name/fetch' target='_blank'>https://davidwalsh.name/fetch</a>. At the end of the next lab we learn how an API server can handle this fetch request. In this lab, the content of <code>/public/linkblog/dummy.json</code> or <a href='http://localhost:8091/linkblog/dummy.json' target='_blank'>http://localhost:8091/linkblog/dummy.json</a> is returned.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-7-ui-writing-to-an-api-example-firebase-">Lab 7: UI Writing to an API (Example: Firebase)</h2>
<ol>
<li><p>In a browser, return to the linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>, and click the &#39;Add Item&#39; button to see <a href='http://localhost:8091/admin/linkblog/detail.html' target='_blank'>http://localhost:8091/admin/linkblog/detail.html</a>. Note that the date field is pre-populated with today&#39;s date. In VS Code, inspect <code>/public/admin/linkblog/detail.pug</code>. This file defines the composition of the linkblog &#39;Add Item&#39; screen. In the HTML part of this file, the data entry form represented by the pug statement <code>&#39;form#form1&#39;</code> (<code>&#39;&lt;form id=&quot;form1&quot;&gt;&#39;</code>). Note that it has <code>&#39;onsubmit=&#39;return false&#39;</code>, because we do not want the browser default behavior of posting to a form action URL.
-, and the two pages belong together - we have chosen to augment <code>LinkblogBusiness.js</code> with the <code>&#39;detail()&#39;</code> and <code>&#39;save()</code>&#39; functions rather than creating separate <code>LinkblogListBusiness</code> and <code>LinkblogAddBusiness</code>. For a different module we would create a separate <code>XxxBusinness</code>.</p>
</li>
<li><p>Reopen <code>/topseed-webroot/admin/linkblog/LinkblogBusiness.js</code> and locate the <code>&#39;detail: function(&#39;</code>. We use <a href='https://momentjs.com/' target='_blank'>https://momentjs.com/</a> for date handling and jquery.jsForm from <a href='https://github.com/corinis/jsForm' target='_blank'>https://github.com/corinis/jsForm</a> to populate the form with the date. The necessary libraries are loaded in <code>/_js/admin.js</code>. You see the result of the call to <code>&#39;detail()&#39;</code> when rendering of the page has completed.</p>
</li>
<li><p>Fill some data in the form and click &#39;Save&#39;. You should see an alert that saving is not enabled: we are not yet configured to use a database that allows saving. In <code>LinkblogBusiness.js</code>, locate the <code>&#39;save: function(&#39;</code>. Once we enable <code>&#39;update&#39;</code> in the <code>urlSpec</code>, processing will continue. We obtain the <code>&#39;formData&#39;</code> with <code>&#39;jquery.jsForm(&#39;get&#39;)&#39;</code>, and pass it to the <code>&#39;linkblogDao.update&#39;</code> function. Once this has returned successfully (<code>&#39;promise.then(&#39;</code>), we redirect to the list page. <code>BLX</code>/<code>sb</code>has base functionality using turbo for the new page load.</p>
</li>
<li><p>Reopen <code>BDS</code> and look for <code>&#39;update: function(&#39;</code>. It calls a shared static <code>_post</code> function which uses <code>fetch_</code> to call the <code>urlSpec</code> update URL. </p>
</li>
<li><p>It is time to connect <code>LinkblogDao</code>/<code>BDS</code> to a live database. Go to the top of <code>LinkblogBusiness.js</code>, comment out the first <code>urlSpec</code> and comment in the <code>urlSpec</code> that goes to localhost:8081, does not use <code>dummy.json</code> and also has an <code>update</code> route, unlike the first <code>urlSpec</code>. We included a basic API server implementation in the topseed project at <code>/topseed/bsrv</code> that we will run at localhost:8081. The API server in turn will call a Google Firebase service that you will configure in the next step. Why do we not call the Firebase API directly from the browser? We do not want the browser to hold the authentication credentials for the database connection (more about user authentication in the next tutorial).</p>
</li>
<li><p>Log into your Gmail/Google account at <a href="https://mail.google.com">https://mail.google.com</a> (Create one if you don&#39;t have one). Navigate to <a href='https://console.firebase.google.com/' target='_blank'>https://console.firebase.google.com</a>, click &#39;Add Project&#39;, enter &#39;mydb1&#39; as Project name when prompted and click &#39;Create Project&#39;.
Click the &#39;gear&#39; icon on the left menu (enlarge browser window if necessary to see it) to access Project Settings and click the &#39;Service Accounts&#39; tab. Copy the <code>&#39;databaseURL&#39;</code> value from the Node.js Admin SDK configuration snippet and paste it into the  <code>/topseed/bsrv/config/ApiConfig.js</code> <code>DB_URL</code> return value. The line in <code>ApiConfig.js</code> should look something like <code>&#39;get DB_URL() { return &#39;https://mydb1-7b77e.firebaseio.com&#39; }&#39;</code> On the Google Project Settings Service Accounts tab, click &#39;Generate New Private Key&#39; and &#39;Generate Key&#39;. From the download prompt, save the file into the <code>/topseed/bsrv/scode/route/ds/</code> folder. Open <code>BaseFB.js</code>, and replace <code>&#39;serviceKey.json&#39;</code> with the filename. The line should look something like <code>&#39;const &#39;serviceAccount = require(&quot;./mydb1-7b77e-firebase-adminsdk-8swi6-f46e592e60.json&quot;)&#39;</code>. Verify that the path starts with <code>&#39;./&#39;</code>.</p>
</li>
<li><p>You are ready to start the API server that uses this configuration. In VS Code, open another Terminal Shell <code>(Ctrl+Shift+`)</code>, type <code>&#39;cd bsrv [Enter]&#39;</code>, do the <code>&#39;npm install [Enter]&#39;</code> and then <code>&#39;node index [Enter]&#39;</code>.
You should see console output &#39;API server listening at <a href="http://localhost:8081">http://localhost:8081</a>&#39;. On the VS Code terminal tab, use the dropdown go to the tab for topseed-srv, and start topseed-srv if not already running. You should see console output &#39;Web server listening at <a href="http://localhost:8091">http://localhost:8091</a>&#39; (and 8092).</p>
</li>
<li><p>In a browser, go to or refresh the linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a>. The list should now say &#39;No data available in table&#39;, because <code>LinkblogBusiness</code> <code>&#39;urlSpec&#39;</code> points to the newly configured API server that has an &#39;empty&#39; database. Click &#39;Add Item&#39;, enter some values and click &#39;Save&#39;. Your item should appear in the list. Back in the Google Firebase Console at <a href='https://console.firebase.google.com/' target='_blank'>https://console.firebase.google.com/</a>, for the project &#39;mydb1&#39;, navigate to &#39;Database&#39; from the menu tree on the left. You should be able to drill down to see the newly created entry in a table named &#39;links11&#39;. If you like, return to the linkblog list at <a href='http://localhost:8091/admin/linkblog/' target='_blank'>http://localhost:8091/admin/linkblog/</a> in the browser and add a few more items with &#39;Add Item&#39;.</p>
</li>
<li><p>Optional: Learn how the API server at <code>/bsrv</code> works. Inspect <code>/bsrv/index.js</code>. The line beginning with <code>&#39;server.use(&#39;/linkblog&#39;&#39;</code> specifies that any requests to localhost:8081/linkblog are handled
by <code>/scode/route/LinkblogService.js</code>. Inspect this file. The function beginning with <code>&#39;router.post(&#39;/&#39;&#39;</code> specifies in the line <code>&#39;const _promise = linkblog.update(row)&#39;</code> that a post request will call the <code>&#39;update&#39;</code> function in <code>/ds/Linkblog.js</code>. Inspect this file. <code>Linkblog.js</code> specifies the table name as &#39;links11&#39;, but also extends <code>BaseFB</code>. (Since <code>Linkblog.js</code> runs in the Node.js server and not in the browser, we can use <code>&#39;extends&#39;</code> instead of <code>&#39;.extends([&#39;</code>). <code>BaseFB</code> has the common functionality to create a Firebase connection, query and update the database. For this, it uses the &#39;firebase-admin&#39; package imported as a dependency in <code>/bsrv/package.json</code>. To add a row, the <code>BaseFB.js</code> function <code>&#39;update(row)&#39;</code> was used. Similarly, a &#39;get&#39; request to localhost:8081/linkblog uses <code>BaseFB.js</code> <code>&#39;selectList()&#39;</code> to obtain the list of linkblog items. </p>
</li>
<li><p>Perspective: For a complete Create-Read-Update-Delete (CRUD) implementation, we would add single-row query, update and delete capability. To edit existing items, we would navigate to <code>&#39;/detail.html?id=x&#39;</code> and, in <code>LinkblogBusiness</code> <code>&#39;detail()&#39;</code>, use the <code>&#39;id&#39;</code> URL parameter to obtain the existing data querying by a primary key column or unique index on the database. If you were to use a database service provider other than Google Firebase, you would create an implementation of <code>BaseFB.js</code> using the alternative provider&#39;s API, following the provider&#39;s examples for Node.js. </p>
</li>
</ol>

<p>new-page</p><h2 id="lab-8-log-in-security-and-tokens">Lab 8: Log-in Security and Tokens</h2>
<ol>
<li><p>Until now we had log-in security for the Admin module disabled. Inspect <code>/admin/home/index.pug</code>, and look for the section beginning with  <code>&#39;if (!Cookies.get(&#39;auth&#39;))</code>. Uncomment the section by removing <code>&#39;//&#39;</code>. Ensure the API service from the previous tutorial is running on port 8081. Return to the home page at <a href='http://localhost:8091' target='_blank'>http://localhost:8091</a>, and click the &#39;Admin&#39; menu item to see the login prompt. Use <code>&#39;demo&#39;:&#39;demo&#39;</code> as username:password and click &#39;Login&#39;. In VS Code, return to <code>/admin/login/index.pug</code>. See how we open the modal dialog, bind the form and register the form submit. Modal dialogs are natively supported by the Chrome browser. We use a <em>polyfill</em> (loaded in <code>/\_js/admin.js</code>) for compatibility with other browsers (Edge and IE need a little bit of CSS love). <code>LoginBusiness</code> <code>&#39;login()&#39;</code> contacts the API server (it could be a separate server dedicated to authentication). If the credentials match, LoginBusiness receives an &#39;OK&#39; response, and we redirect to <code>/admin/home/</code>. If an authentication error is received, we display it in a <code>&#39;div&#39;</code> with <code>id &#39;error&#39;</code> on the page.</p>
</li>
<li><p>Along with the &#39;OK&#39; response, the API server returned a &#39;token&#39; string. We store the token as a cookie (name: <code>&#39;auth&#39;</code>) in the browser. After the initial log-in, we use this token on all pages and for all API calls that require authentication. While we could have stored username and password as a cookie instead, the advantage of using a token after initial authentication is that it can be heavily encoded. For maximum security and defense against network sniffing, the token could even be changed on every request.</p>
</li>
<li><p>To protect the linkblog pages with a log-in, open <code>/admin/linkblog/index.pug</code> and <code>/detail.pug</code> and uncomment <code>&#39;//sb.ensureLogin(...)&#39;</code>. This function checks for the existence of the <code>&#39;auth&#39;</code> cookie. If this cookie doesn&#39;t exist, it means that the user has not logged in, and he is redirected to the log-in screen. We destroy the <code>&#39;auth&#39;</code> cookie on log-out; see <code>&#39;script.&#39;</code> in <code>/admin/logout/index.pug</code>. Log-out is triggered when clicking the admin menu &#39;Logout&#39; item.</p>
</li>
<li><p>There is one more thing to improve. In our flow, on full page refresh, the browser renders the static parts of the page before ensuring log-in. The ugly result is that the admin menu bar, static page content and footer may briefly display before a redirect to the log-in page happens. This is by design; we allow a CDN to cache the static (non-data) parts of admin module pages. However, we can apply a visual improvement to achieve better transitions. Open <code>_sass/admin.sass</code> and uncomment the last two lines, beginning with <code>&#39;//body \&gt; *&#39;</code>. This sets the opacity of the immediate children of the admin HTML <code>&#39;body&#39;</code> to a very low <code>&#39;0.1&#39;</code> by default (You can set it to <code>&#39;0&#39;</code>, if you prefer). <code>&#39;Linkblog.ensureLogin&#39;</code> sets the opacity to <code>&#39;1&#39;</code> when the user has been confirmed to have successfully logged in, causing the page to display in full. Save <code>admin.sass</code> and try the log-in routine again to see the result. We could also imagine using a <em>spinner</em> during the transition; see <a href='http://spin.js.org/spinner' target='_blank'>http://spin.js.org/spinner</a>. </p>
</li>
<li><p>For additional security, we send the token along when we make requests to the API server. If the API server is configured to require authentication, we ensure that the specific token received allows reading or writing the data before returning the data. If the token is not valid, we let the API service return a 403 &#39;Forbidden&#39; error. When <code>LinkblogBusiness</code> receives such an error, we show an alert and redirect to the log-in page. Open <code>/data-topseed-io/config/ApiConfig.js</code> to configure which API calls are to be secured. In the line for <code>&#39;get REQUIRE_AUTH&#39;</code>, uncomment <code>&#39;write&#39;</code> so that it reads <code>&#39;linkblog: [&#39;write&#39;]&#39;</code>. Restart the server in the terminal window. This activates the token check in <code>/data-topseed-io/server/route/LinkblogService.js</code> in <code>&#39;router.post(&#39;</code>. The class <code>&#39;TokenAuth&#39;</code> contains our very simple authentication functionalities: validate that username:password match demo:demo, and the token always matches &quot;abc&quot;. </p>
</li>
<li><p>You just activated token security for the <code>Linkblog</code> <code>&#39;write&#39;</code> (=save) function. Let&#39;s inspect how the token is passed to the API. In <code>/admin/linkblog/detail.pug</code>, with <code>&#39;$(&#39;#form1&#39;).submit({auth: Cookies.get(&#39;auth&#39;)}, sb.save)&#39;</code> we instruct to include the auth cookie as event data when calling <code>&#39;LinkblogBusiness.save&#39;</code>. From there we pass it on to the DAO in <code>&#39;sb.linkblogDao.update(formData, e.data.auth)&#39;</code>. This continues through <code>BDS.js</code> <code>&#39;update&#39;</code>, <code>&#39;\_post&#39;</code> and <code>&#39;fetch_&#39;</code> functions, where the token is  passed to the API as &#39;X-JToken&#39; header. If configured as described above, in <code>/data-topseed-io/server/route/LinkblogService.js</code> the API reads this header and validates the token by calling <code>/route/ds/TokenAuth.js &#39;isTokenValidPromise&#39;</code>. 
Inspect this function. The returned promise throws an &#39;invalid token&#39; error in the case of failure, which causes <code>LinkblogService</code> to abandon the update request and return a 403 error &#39;Forbidden&#39;.</p>
</li>
<li><p>Reopen <code>/admin/linkblog/LinkblogBusiness.js</code> and find <code>&#39;const _updatePromise&#39;</code>. Here follows what happens in the UI as a result of the update attempt. If the update/save was successful, we redirect to the linkblog list page. If it failed because the token did not validate (&#39;Forbidden&#39;), show an alert and redirect to the login page. In case of other failures, simply show an alert. If you wish to simulate the errors, go to <code>/admin/linkblog/detail.pug</code> and make it send an invalid<code>&#39;auth&#39;</code> value with <code>&#39;$(&#39;#form1&#39;).submit({auth: &#39;XYZ&#39;}, sb.save)&#39;</code>. Attempt to add and save a new linkblog item. Revert to <code>&#39;$(&#39;#form1&#39;).submit({auth: Cookies.get(&#39;auth&#39;)}, sb.save)&#39;</code> when done. Since our linkblog is expected to be public, we didn&#39;t implement authentication for the <code>&#39;linkblogDAO.selectList&#39;</code> API call, but this could easily be added.</p>
</li>
<li><p>This tutorial demonstrated the fundamentals of the two principal authentication flows: log-in and token validation. A &#39;real life&#39; authentication provider would likely be more advanced than <code>TokenAuth.js</code>. Tokens might need to be encoded and decoded. A production implementation might access a database of credentials, an in-memory database of valid tokens, or an asynchronously called external authentication service that may return its own promises for credential and token validations. In the shown implementation, successful log-in always redirects to the admin landing page. For production, we would probably enhance the log-in flow by keeping track of which protected page was requested and redirect to it after successful log-in. </p>
</li>
</ol>

<p>new-page</p>
<h2>Part III: The Perspectives</h2>
<p>new-page</p><h2 id="lab-9-standard-web-components-and-their-communication">Lab 9: Standard Web Components and their Communication</h2>
<ol>
<li><p>The quest for the web equivalent of &#39;Legos&#39; has been going on for a while. Legos are <em>composable</em>: you can connect pieces in different ways. They are <em>reusable</em>: the same kind of piece can be used in multiple places. Legos are also <em>modular</em>: you can connect one assembly to another one. Unlike Legos [<a href='https://www.kickstarter.com/projects/1068475467/brixo-building-blocks-meet-electricity-and-iot' target='_blank'>mostly</a>], however, components for the web also need to be able to <em>communicate</em> with each other and with the outside world. Finally, web components need to be <em>insulated</em> (in Lego terms, the color of one item must not &#39;bleed&#39; into others). CSS bleed has been a particular problem of older web component frameworks. To find an overall solution for great web components is not trivial, and many attempts have been made to achieve the holy grail of component-based development for the web.</p>
</li>
<li><p>In reality, component frameworks have had a short half-life. The last years have seen a rapid succession of candidates to be considered &#39;the best&#39;: Backbone, Knockout, Ember, Angular, Angular 2, React, Vue, Riot and Polymer. Find a comparison of component frameworks at <a href='http://jeffcarp.github.io/frontend-hyperpolyglot/' target='_blank'>http://jeffcarp.github.io/frontend-hyperpolyglot/</a>. History shows that what you would pick today is likely not what you would pick eighteen months from now. Assuming you don&#39;t want to start from scratch and rewrite everything every eighteen months, that presents you with a great challenge of how to write applications that you can expect to be both maintainable and future-safe.</p>
</li>
<li><p>Our best practice to deal with the evolving landscape of web components is to write web apps that are structured in a <em>component-framework-agnostic</em> way, where you can potentially keep existing components around, but develop new components using a newer component framework. We achieve this by avoiding the use of the two kinds of common component framework features that create unattractive lock-in: custom navigation mechanisms (routers) and framework-specific component communication implementations. We use the browser&#39;s great native navigation mechanisms (URL and browser history) as shown in <a href="./4-appShell/">Lab 4</a>, and framework-agnostic component communication as implemented in the sample project shown below. </p>
</li>
<li><p>There is, however, light at the end of the tunnel: a W3C standard for web components appears to be forming.  Read about <em>Standard Web Components</em> at <a href='https://en.wikipedia.org/wiki/Web_Components' target='_blank'>https://en.wikipedia.org/wiki/Web_Components</a>. The Chrome browser already supports Standard Web Components natively, so there is nothing extra to load, and the polyfills for the other browers are lean and fast. The most recent contender for &#39;the best&#39; component framework, Polymer, is actually developed on top of this emerging standard. We use Standard Web Components as the default component framework for this Lab. However, our architectural concepts can also be applied when using other frameworks. May we tempt you to write a sample integration for your favorite component framework and contribute it to topseed?</p>
</li>
<li><p>Among other things, newer component frameworks solve the problem of CSS bleeding by using the <em>Shadow DOM</em> construct. To work with web components you should understand Shadow DOM; read a good introduction at <a href='https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/' target='_blank'>https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/</a>. We prefer it over the more recent introduction at 
<a href='https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom' target='_blank'>https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom</a>. <em>Templates</em> and <em>HTML Imports</em> are other Standard Web Component features which will become clear with the examples in this lab. Finally, there is a <em>Custom Element API</em> to create new HTML tags. Unfortunately, this API uses &#39;class&#39; which is not supported by Internet Explorer. (It is possible but a little painful to down-compile for IE.) We will use the Custom Element API once IE has lost its remaining popularity, or when we can rule out IE in a corporate app. </p>
</li>
<li><p>Download and unzip topseed-webcomps-master.zip from <a href='https://github.com/topseed/topseed-webcomps' target='_blank'>https://github.com/topseed/topseed-webcomp</a> to your location of choice on your developer machine. Open the project in VS Code. Add the project folder <code>/topseed-webcomps</code> in Prepros, but but ensure that Pug Auto-Compile is deactivated (Settings/Compiler Settings/Pug (Jade). In this project, Node.js compiles pug files on the fly when responding to HTTP requests so we don&#39;t need Prepros to precompile them. See the function &#39;pugComp&#39; in <code>/server/util/Decider.js</code>. Since in production we cache all generated HTML responses in the CDN, there is practically no impact on production performance, but the development project is a lot cleaner.</p>
</li>
<li><p>In VS Code, open Terminal Shell <code>(Ctrl+Shift+`)</code>, type <code>&#39;cd demo-srv [Enter]&#39;</code>, do the <code>&#39;npm install [Enter]&#39;</code> and then <code>&#39;node index [Enter]&#39;</code>. You should see console output &#39;Web server listening at <a href="http://localhost:9981">http://localhost:9981</a>&#39;. In the browser, navigate to <a href='http://localhost:9981' target='_blank'>http://localhost:9981</a>, and visit Dashboard, List, Circle, Prelist and List menu items. When writing a component, we always advise to make things work outside of a component first. &#39;Prelist&#39; is a non-component list page. In VS Code, inspect its <code>/public/page/list-0/index.pug</code>. Similar to the admin linkblog in tutorials 6 and 7, this page uses <code>/page/list/ListBusiness.js</code> to load a list from a JSON response promise. For data binding, <code>ListBusiness</code> <code>&#39;list()&#39;</code> uses doT.js, a fast &#39;moustache-style&#39; template library. The doT template is embedded in the page html as a script of type <code>&#39;text/x-dot-template&#39;</code>. Inspect ListBusiness.js, beginning with <code>&#39;var templateText&#39;</code> to see the JavaScript used to render the template with data and attach it to <code>&#39;#myList&#39;</code> in the page. You can read more about doT at <a href='http://www.javascriptoo.com/dot-js' target='_blank'>http://www.javascriptoo.com/dot-js</a>.</p>
</li>
<li><p>Inspect the component version of the list page at <code>/public/page/list/index.pug</code>. It has a custom element in the HTML named <code>&#39;list-el&#39;</code>. Custom elements must include a <code>&#39;-&#39;</code> (dash) in the tag name. The doT template has disappeared. The page <code>&#39;script.&#39;</code> loads <code>ListBusiness.js</code> and the List component definition from the HTML Import <code>/_webComp/List.html</code>, registers the <em>component prototype</em> with the browser using <code>&#39;TW.registerComp&#39;</code> and then calls <code>&#39;sb.compList()&#39;</code> to render an <em>instance</em> of the component. In <code>/page/list/ListBusiness.js</code>, compare the function <code>&#39;compList&#39;</code> with the function <code>&#39;list&#39;</code> used by the non-component version. In this example, the <code>&#39;compList&#39;</code> function obtains the component instance with <code>&#39;document.querySelector&#39;</code> and calls its <code>&#39;list(values)&#39;</code> function. We always pass data to a component rather than making the component load data. This keeps the component simpler and more manageable. As a result of using a component, both the page and <code>ListBusiness</code> are somewhat cleaner; any &#39;JavaScript mess&#39; is hidden inside the component.</p>
</li>
<li><p>Optional: Inspect the list component implementation at <code>/public/_webComp/List.pug</code>. You will find the Standard Web Component <code>&#39;template&#39;</code> tag that includes the node <code>&#39;#myList&#39;</code> previously seen in the non-component page, as well as the <code>&#39;x-dot-template&#39;</code>. The <code>&#39;script.&#39;</code> section creates a HTMLElement prototype named <code>&#39;ListEl&#39;</code>, specifies to attach the insulated shadow DOM (using <code>&#39;TW.attachShadow&#39;</code>) when an actual component instance is created from the prototype (<code>&#39;createdCallback&#39;</code>). Also see the <code>&#39;ListEl.list&#39;</code> function implementation which places the databinding result into the <code>&#39;#myList&#39;</code> node in the shadow DOM. (You can find a copy of the <code>&#39;TW.&#39;</code> helper library function implementations in <code>/demo-srv/root2/_js/tw-2.0.js</code>.) </p>
</li>
<li><p>As of the time of writing, due to less than perfect polyfills, CSS still bleeds in both directions in Firefox and Edge. For us this is not catastrophic because we avoid most CSS namespace collisions by using BEM syntax when naming our own component styles. Remaining potential issues with third party styles used inside components will disappear once all browsers natively support Standard Web Components. Read <a href='https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/' target='_blank'>https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/</a> to lean how to use BEM; it is a best practice even when not using components. See <code>/public/_webComp/circle.pug</code> for an example of BEM inside a component. You can also attempt to insulate component CSS by using a scope <code>&#39;div&#39;</code>; see the use of <code>&#39;.bgauge-el&#39;</code> in <code>/_sharedComps/gauge.pug</code>. It is also possible to write components that bleed <em>on purpose</em>, by making components use actual DOM vs. shadow DOM. You may choose to do this if you have a well-managed, globally applicable CSS regime (ideally using BEM throughout), and are not worried about 3rd party style bleeding. Or you can use SASS to bring global CSS styles into the component, analog to using mainA.css inline with AMP as shown in tutorial 5.</p>
</li>
<li><p>In a browser, go to the dashboard page at <a href='http://localhost:9081/page/dashboard/' target='_blank'>http://localhost:9081/page/dashboard/</a>. Inspect the dashboard page at <code>/public/page/dashboard/index.pug</code> for an example of using multiple components in one page. Find the reused <code>&#39;list-el&#39;</code>, as well as <code>&#39;circle-el&#39;</code> and <code>&#39;gauge-el&#39;</code> in the HTML. Inspect <code>&#39;script.&#39;</code> <code>&#39;function UIinit&#39;</code>. Note that the Circle and Gauge components are loaded from absolute URLs. This means that components can easily be shared across different web projects. In this example, <code>ListBusiness</code> is also used as the component communication &#39;message bus&#39; (The message bus features are found in BLX, the base class for <code>ListBusiness</code>.) <code>&#39;sb.addComp&#39;</code> connects each component to the bus, as long as the component implements a function named <code>&#39;init&#39;</code>. (The non-dashboard examples didn&#39;t call <code>&#39;sb.addComp&#39;</code> because their components did not send or receive messages.) Because <code>ListBusines</code>s was already present for loading list data, it was convenient to use it as message bus as well. You can use a separate message bus insteadby using <code>&#39;const _blx = new BLX(null)</code>&#39;.</p>
</li>
<li><p>On the dashboard page at <a href='http://localhost:9981/page/dashboard/' target='_blank'>http://localhost:9981/page/dashboard/</a>, click on one of the list links to see how the circle and gauge display values change. Repeat for each list item. The list component has detected that it is enabled to communicate and has pushed hidden list data (values for circle and gauge) to the bus (rather than just opening a new tab). Because circle and gauge components are also registered with the bus, they receive the values and use their component-specific implementation to update the display. This way, components are loosely coupled. </p>
</li>
<li><p>Optional: Learn about the component communication implementation. First inspect the function <code>&#39;addComp&#39;</code> at <code>/public/page/list/ListBusiness.js</code>; it passes a reference to the bus component. Look at the <code>&#39;ListEl.init&#39;</code> function in <code>/public/_webComp/List.pug</code>. The component instance <code>&#39;listEl&#39;</code> keeps a reference to the bus. In the same file, look for the <code>&#39;text/x-dot-template&#39;</code> and see how <code>&#39;listEl.nav&#39;</code> is triggered when the user clicks on the link. Inspect the function definition <code>&#39;ListEl.nav&#39;</code>. It sends the data to the bus using key &#39;mySelection&#39;; see <code>&#39;blx.emit(&#39;mySelection&#39;</code>. In the Circle component implementation at <code>/public/_webComp/circle.pug</code>, find function <code>&#39;CircleEl.init&#39;</code> (the equivalent of <code>&#39;ListEl.init&#39;</code> for the Circle compoment). With <code>&#39;_blx.on(&#39;mySelection&#39;...&#39;</code> it specifies to update the component display when the bus received a message with key &#39;mySelection&#39;. In summary, the components are &#39;loosely coupled&#39; because neither component requires the presence of other components. </p>
</li>
<li><p>We like creating and using components when it make us more productive, and the code becomes more maintainable. We decide this per use case. Be your own judge! </p>
</li>
<li><p>If this tutorial felt a little heavy, we would be happy to help get you started with in-house seminars, workshops and &#39;training the trainer&#39;.  That applies to other labs as well.  Just email us at hi [at] appthings.io.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-10-server-side-rendering-ssr-of-web-components">Lab 10: Server-side rendering (SSR) of Web Components</h2>
<ol>
<li><p>We saw in Lab 9 that Web Components can be great for productivity by promoting reuse, and thanks to encapsulation they can improve maintainability as well. So far you saw components that are rendered client-side, beginning with JavaScript loading. Unfortunately, this dynamic loading still presents challenges for most search engines (only Google uses a virtual Chrome engine that executes JavaScript when crawling). Content rendered by Web Components can not be seen by all search engines. We also see that especially browsers that still require polyfills take a little longer to render Web Components, and we wish to reduce this &#39;time to glass&#39; to an absolute minimum.</p>
</li>
<li><p>Fortunately, in many situations both issues can be overcome with <em>Server-Side Rendering</em> (SSR). The idea of SSR is to make the server render the component and deliver the render result as part of the page HTML that is delivered to the browser. The user sees the content more quickly because the browser does not need to retrieve additional content for display. If the component needs additional browser interactivity (e.g. custom JavaScript on-click), we still load the component JavaScript into the browser to provide that interactivity functionality, and upgrade the (server-side generated) html with these features in the browser. We would call this kind of component a <em>hybrid</em>, as some features are delivered on the server, and some are delivered in the browser. The result of this technique is a greater perceived performance for the user as well as full visibility of the content by search engines. Depending on the frequency of content changes, the complete page may still be cached by a CDN. If not, it may take a little longer to prepare the main page response, but in many cases the server will have higher bandwidth and more resources to process the loading tasks than the user&#39;s device.</p>
</li>
<li><p>Download and unzip topseed-ssr-master.zip from <a href='https://github.com/topseed/topseed-ssr' target='_blank'>https://github.com/topseed/topseed-ssr</a> to your location of choice on your developer machine and open the project in VS Code. Open Terminal Shell <code>(Ctrl+Shift+`)</code>, type <code>&#39;cd ssr-topseed-io [Enter]&#39;</code>, do the <code>&#39;npm install [Enter]&#39;</code> and then <code>&#39;node index [Enter]&#39;</code>. You should see console output &#39;Web server listening at http://localhost:9081&#39;. In the browser, navigate to <a href='http://localhost:9081' target='_blank'>http://localhost:9081</a>, and visit Dashboard, List, Circle, Prelist and List menu items. If you use Prepros on this project, ensure that auto-compile for Pug is turned off.</p>
</li>
<li><p>Revisit the Dashboard page. It contains two server-side rendered components: &#39;Myssrcomp&#39; and &#39;List&#39;. Especially in Firefox and Edge it should be noticable that these components display more quickly than the others. On the &#39;List&#39; page, the component is rendered server-side as well. If you inspect the raw HTML in the browser (e.g. with &#39;Rightclick-View Page Source&#39;) you can find the component content &#39;Hi this is myssrcomp1&#39; in the markup.</p>
</li>
<li><p>SSR components can use Shadow DOM for CSS encapsulation but they don&#39;t have to. We use a process called &#39;rehydration&#39; in the browser to apply Shadow DOM.  On the server, we wrap the content to be subjected to Shadow DOM in a <code>&lt;shadow-root&gt;</code> tag. Inspect <code>/public/page/dashboard/index.pug</code> and find the call to  <code>TW.rehydrate(&#39;my-ssrcomp&#39;)</code>, which converts the tag to an actual Shadow DOM with its scoped CSS. (Efforts are underway with the WC3 to make this standard browser behavior, eventually eliminating the need for this JavaScript). In this example the content is rendered before the Shadow DOM is in place, leading to potential style conflicts, but we could avoid that with CSS of <code>shadow-root * {opacity:0}</code> or similar.</p>
</li>
<li><p>Inspect <code>/server/route/dashboard/index.js</code>. The route (installed in <code>/topssed-ssr-io/index.js</code>) renders the HTML of the named components &#39;Myssrcomp&#39; and &#39;List&#39; and embeds it in the otherwise static page HTML retrieved from <code>/public/page/dashboard/index.pug</code>. In our utility library at <code>/server/util/SR.js</code>, we use <em>skatejs/ssr</em> for the actual server-side rendering of each component HTML, and <em>Cheerio</em>, a server-side version of JQuery to embed it in the page. In <code>/server/route/dashboard/index.js</code>, we also specify that the &#39;List&#39; component has to obtain custom data before rendering by setting the <code>initFn</code> for this component (It is our good practice to keep business logic outside of components, i.e. framework-agnostic and thus more future-safe).</p>
</li>
<li><p>Inspect the &#39;List&#39; component HTML Template at <code>/public/_webComp/List.pug</code> and see where we use the <code>&lt;shadow-root&gt;</code> tag to mark the Shadow DOM. The component JavaScript is separated out at <code>/public/_webComp/List.js</code> so it can be loaded separately from the client side for the upgraded &#39;hybrid&#39; features (this is done in <code>/public/page/dashboard/index.pug</code> with a  call to  <code>TW.loadComp(&#39;/_webComp/List.js&#39;)</code>)</p>
</li>
<li><p>Inspect the &#39;List&#39; component Custom Element JavaScript at  <code>/public/_webComp/List.js</code>. See how we use a test for &#39;module&#39; in <code>connectedCallback</code> to trigger server-side only functionality. In this example, the component&#39;s <code>list</code> function is used on the server, and the <code>nav</code> function is used on the client. To provide compatibility with IE11, we would down-compile these ES6 components to ES5. With a little bit of work (such as a tag attribute <code>ssr=&#39;true&#39;</code>), this component could be made fully <em>Universal</em>, i.e. usable as a hybrid as well as a pure client-side component. </p>
</li>
<li><p>In practice, for our own components we decide on a case-by-case basis whether the component really needs a Shadow DOM, and whether it should be rendered server-side or client-side. Perceived performance and the need for SEO would be the main decision criteria.</p>
</li>
<li><p>Like tutorial 9, if this tutorial felt a little heavy, we would be happy to help get you started with in-house seminars, workshops and &#39;training the trainer&#39;.  That applies to other labs as well.  Just email us at hi [at] appthings.io.</p>
</li>
</ol>

<p>new-page</p><h2 id="lab-11-mobile-app-phonegap-">Lab 11: Mobile App (Phonegap)</h2>
<ol>
<li><p>In this lab we will customize and install an Android app that uses the <em>Cordova In-App Browser</em> to provide a rich UI. Download and unzip <code>topseed-mobile-master.zip</code> from <a href='https://github.com/topseed/topseed-mobile' target='_blank'>https://github.com/topseed/topseed-mobile</a> to your location of choice on your developer machine. Open the project in VS Code. Download, install and run the Phonegap Desktop App from <a href='https://github.com/phonegap/phonegap-app-desktop/releases' target='_blank'>https://github.com/phonegap/phonegap-app-desktop/releases</a>. In Phonegap Desktop, add the <code>/topseed-mobile</code> folder as a Project, and click the &#39;&gt;&#39; button. A message &#39;Server is running on...&#39; should come up. Click on the URL to open the app in a browser. Resize the browser to mobile phone format. </p>
</li>
<li><p>The app is configured to show a splash screen and then display content obtained from <code>https://m.appthings.io</code>. We will make it display the content you published to the CDN in <a href="./3-goLive/">Lab 3</a> instead. As you edit the project, the Phonegap Desktop App watches for changes in the <code>/www</code> folder of the project and attempts to refresh the browser view on each change. In <code>/www/js/index.js</code>, replace the URL following <code>&#39;window.open</code>&#39; with the homepage URL of the helloworld app you deployed in Lab 3, i.e. your equivalent of <code>https://staging.mydomain.com/page/one/index.html</code>. If you only deployed to the CDN or <code>zeit.co</code>, use your equivalent of <code>https://1234567890.rsc.cdn77.org/page/one/index.html</code>. or <code>https://demos-oosnsyzlphl.now.sh/page/one/index.html</code>. If you never deployed, you can use the published version of this tutorial at <code>https://docs.topseed.io/tutorial/0-agenda/index.html</code>. By including <code>&#39;/index.html&#39;</code> in the path we ensure to deliver the turbo (non-AMP) version of the page with its smoother transitions and rich client app feel.</p>
</li>
<li><p>To allow the in-app browser to navigate to the newly configured URL, in <code>/config.xml</code> <code>&lt;allow-navigation href=&quot;https://m.appthings.io/*&quot; &gt;</code>, replace <code>&#39;m.appthings.io&#39;</code> with your equivalent from the previous step. The app should now display your site at the 
Phonegap Desktop App Server URL. It is a labor of love to replace the splash screen logo (at <code>/www/css/index.css</code>) and the icons used by the phone operating system (see <code>/config.xml</code> <code>&#39;icon&#39;</code> values) with your own; we will skip over it here. Optional: change the values for the app <code>&#39;name&#39;</code> and <code>&#39;version&#39;</code> in <code>/config.xml</code>.</p>
</li>
<li><p>To install the customized app on an Android phone, 
first create a zip file of the contents of the project folder <code>/topseed-mobile</code>. Create an account and login at <a href='https://build.phonegap.com' target='_blank'>https://build.phonegap.com</a>. 
On the &#39;Apps&#39; tab at <a href='https://build.phonegap.com/apps' target='_blank'>https://build.phonegap.com/apps</a>, click the &#39;+ new app&#39; button and upload the zip file (If your project is in Github, you can use the Github clone URL instead). The site will take a few moments to build the app. Meanwhile, also log into <a href='https://build.phonegap.com' target='_blank'>https://build.phonegap.com</a> on your mobile phone. Once the build has completed, on your phone download, install and run the version for your phone&#39;s operating system (here: Android). Follow the installation prompts. Done! For fun, close the app and reopen it by tapping on the app icon on your phone UI.</p>
</li>
<li><p>See <a href='http://docs.phonegap.com/' target='_blank'>http://docs.phonegap.com/</a> for further information about Phonegap, for instruction how to deploy to Apple iOS, and how your app can access phone-specific APIs, such as address book, location information etc. if necessary. We would use a <em>service worker</em> to support offline-browsing as needed.</p>
</li>
<li><p>In this lab we used the Cordova In-App Browser to render app content from a CDN. As shown in <a href="./7-write/">Lab 7</a>, the app can also obtain data securely from separate API servers. Thanks to AppShell, Turbo and caching introduced in <a href="./4-appShell/">Lab 4</a>, the app has a smooth single page application feel. As a result, we were able to develop a rich mobile app without requiring any special Android SDK/iOS development skills. </p>
</li>
</ol>
