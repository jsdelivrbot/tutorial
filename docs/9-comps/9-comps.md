## Lab 9: Standard Web Components and their Communication 

1. The quest for the web equivalent of 'Legos' has been going on for a while. Legos are composable: you can connect pieces in different ways. They are reusable: the same kind of piece can be used in multiple places. Legos are also modular: you can connect one assembly to another one. Unlike Legos <a href='https://www.kickstarter.com/projects/1068475467/brixo-building-blocks-meet-electricity-and-iot' target='_blank'>(mostly)</a>, however, components for the web also need to be able to communicate with each other and with the outside world. Finally, web components need to be insulated (in Lego terms, the color of one item must not 'bleed' into others). CSS 'bleed' has been a particular problem of older web component frameworks. To find an overall solution for great web components is not trivial, and many attempts have been made to achieve the holy grail of component-based development for the web.

2. In reality, component frameworks have had a short half-life. The last years has seen a rapid succession of candidates to be considered 'the best': Backbone, Knockout, Ember, Angular, Angular 2, React, Vue, Riot and Polymer. Find a comparison of component frameworks at <a href='http://jeffcarp.github.io/frontend-hyperpolyglot/' target='_blank'>http://jeffcarp.github.io/frontend-hyperpolyglot/</a> History shows that what you would pick today is likely not what you would pick 18 months from now. Assuming you don't want to start from scratch and rewrite everything every 18 months, that presents you with a great challenge of how to write applications that you can expect to be both maintainable and future-safe.

3. Our best practice to deal with the evolving landscape of web components is to write webapps that are structured in a 'component-framework-agnostic' way, where you can potentially keep existing components around, but develop new components using a newer component framework. We can achieve this by avoiding the use of the two kinds of common component framework features that create unattractive 'lock-in': custom navigation mechanisms (routers) and framework-specific component communication implementations. We advocate using the browser's great native navigation mechanisms (URL and browser history) and framework-agnostic component communication. 

4. There is, however, light at the end of the tunnel: a W3C standard for web components appears to be forming.  Read about Standard Web Components <a href='https://en.wikipedia.org/wiki/Web_Components' target='_blank'>here</a>. The Chrome browser supports them natively, so there is nothing extra to load, and the polyfills for the other browers are lean and fast. The most recent contender for 'the best' component framework, Polymer, is already developed on top of this emerging standard, by the same people at Google in charge of the standard reference implementation. While we use standard web components as the default component framework for this Lab, our architectural concepts can be applied when using other frameworks, too. May we tempt you to write a sample integration for your favorite component framework and contribute it to topseed?

5. Newer component frameworks solve the particular problem of CSS bleeding by using the 'Shadow DOM' concept. To work with web components you should understand Shadow DOM, read this <a href='https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/' target='_blank'>good introduction</a>. We prefer it over the more recent introduction 
<a href='https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom' target='_blank'>here</a>. 'Templates' and 'HTML Imports' are other features which will become clear with the examples in this Lab. Finally, a part of Standard Web Components are 'Custom Elements', an API to create new HTML tags. However, the standard custom elements implementation uses 'class' which is not supported by Internet Explorer. We will use it once IE has lost its remaining popularity, or when we can rule out IE in a corporate app. 

6. Download and unzip topseed-webcomps-master.zip from <a href='https://github.com/topseed/topseed-webcomps' target='_blank'>here</a> to your location of choice on your developer machine. Open the project in VS Code. Add the project root folder in Prepros. Deactivate compilation of Pug (Jade) for this project. /util/Decider.js in this project compiles pug files on the fly when responding to HTTP requests, so we don't need to precompile them. Since we cache generated HTML responses in the CDN, there is practically no impact on performance, but the development project is a lot cleaner. 

7. ...TBD... etc.

